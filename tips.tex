%! TEX root = CS_tips.tex

%% Some random tips for bash and common commands. You'll find computer languages and git tips too.
%%
%% Copyright 2020 Riccardo Milani
%%
%% Licensed under the "THE BEER-WARE LICENSE" (Revision 42):
%% Riccardo Milani wrote this file. As long as you retain this notice you
%% can do whatever you want with this stuff. If we meet some day, and you think
%% this stuff is worth it, you can buy me a beer or coffee in return


\documentclass[a4paper,12pt,%
              final%
              %draft%
              ]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyvrb}

\usepackage{xcolor}
\definecolor{BlueX}{RGB}{0,62,92}

\usepackage[top=2cm, bottom=2cm, left=1cm, right=1cm]{geometry}

%\renewcommand{\ttdefault}{pcr}
\usepackage{listings}
\lstset{%
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
}

\usepackage{hyperref}

\usepackage{enumitem}
%
\begin{document}

% Title
\begin{center}
\bfseries \scshape \Huge \color{BlueX}%
Tips \& stuff
\end{center}
%
\vspace*{\baselineskip}

Some tips about terminal commands (\texttt{sed}, \texttt{grep}\ldots) and languages (\texttt{C}, \texttt{python}\ldots) are given here. For terminal commands, mind that you can access the related \emph{man}ual/help page by running
\begin{verbatim}
man <cmd>
\end{verbatim}
or sometimes
\begin{verbatim}
<cmd> --help
\end{verbatim}

\emph{Notations and conventions.} You will find stuff inside angle brackets (like this \verb|<.>|): this is something that you can choose. You will also find other stuff within square brackets (like this \verb|[.]|, and they can be nested): this indicates something that is optional.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shell}
\label{sec:shell}
There are different version of shells scripting, such as \texttt{bash}, \texttt{sh}, \texttt{zsh}; they have some differences in commands and syntax (but I do not know them \verb|\o/|).
\begin{itemize}
  \item Of course I'm not the first to write tips, and certainly not the one which knows the most, so here a couples of tips lists, especially about shortcuts: \href{https://www.techrepublic.com/article/20-terminal-shortcuts-developers-need-to-know/}{here} and \href{https://www.howtogeek.com/howto/ubuntu/keyboard-shortcuts-for-bash-command-shell-for-ubuntu-debian-suse-redhat-linux-etc/}{here} and \href{https://devhints.io/bash}{here}.
  \item Default applications: often we don't know the name of the programs that we use, for instance, for opening a pdf. Here some of them
    \begin{itemize}
      \item \texttt{evince} for pdf.
      \item \texttt{eog} for images.
      \item \texttt{nautilus} for file explorer.
    \end{itemize}
  \item Run in background:
    \begin{itemize}
      \item Add a \verb|&| after a command to run it back ground, meaning that it won't block the terminal while running, so that you can still use the terminal window for other stuff. This is quite useful when opening GUI programs (e.g.~\texttt{evince}).
      \item Precede your commands with \texttt{nohup} in order to have them running ever after the terminal window / session is closed. More \href{https://linux.101hacks.com/unix/nohup-command/}{here} or \href{https://hexadix.com/use-nohup-execute-commands-background-keep-running-exit-shell-promt/}{here}.
    \end{itemize}
  \item Some built-in variables:
    \begin{itemize}
      \item \verb|$#|: number of arguments passed to the script
      \item \verb|$<n>|: argument \texttt{n}. It is 1-based, in fact \verb|$0| expands to shell / script's name
      \item \verb|$@|: all arguments. You can use it in a list: \verb|for arg in "${@}"|
      \item \verb|$!|: expands to the last run process's ID
      \item \verb|$?|: return value of last command. You can store it \verb|ret_val=$?| or use it directly
\begin{verbatim}
some_command
if [ $? -eq 0 ]; then
echo OK
else
echo FAIL
fi
\end{verbatim}
    \end{itemize}
  \item Operator \texttt{*} expands to all the files whose name does not start with "\texttt{.}". Hence, hidden files (as well as current directory "\texttt{.}", and parent directory "\texttt{..}" are not included).
  \item Arithmetic operations: \verb|$((4*n+3))|, notice that once inside the variables do not need the \$ sign. As it is the case for operator \verb|[| (cf. \autoref{sec:misc}), \verb|((| is a shortcut for a command, precisely \href{https://www.computerhope.com/unix/bash/let.htm}{\texttt{let}}. On shell such as \texttt{bash} only integers arithmetics are allowed. Many alternatives are available, for instance using \texttt{awk} (\autoref{sec:awk}) or \texttt{python} (\autoref{sec:python}) or \texttt{bc} (\autoref{sec:misc}). Others may be found \href{https://unix.stackexchange.com/questions/40786/how-to-do-integer-float-calculations-in-bash-or-other-languages-frameworks}{here}.
  \item Conditional statements: \href{https://unix.stackexchange.com/questions/306111/what-is-the-difference-between-the-bash-operators-vs-vs-vs}{here}
  \item Pipes: \verb!|! connects standard output of one command to standard input of another.
  \item File descriptors:
    \begin{enumerate}[start=0]
      \item Standard input
      \item Standard output
      \item Standard error
    \end{enumerate}
  \item \href{https://www.gnu.org/software/bash/manual/bash.html#Redirections}{Redirection}: use \verb|>| to redirect, \verb|>&| to duplicate and redirect
    \begin{itemize}
      \item Redirect \texttt{stdout} to \texttt{stderr}: \verb|<cmd> 1>&2|
      \item Redirect \texttt{stdout} and \texttt{stderr} to file: first we redirect \texttt{stdout} to a file then we tell to copy \texttt{stderr} to \texttt{stdout}
\begin{verbatim}
  <cmd> > file.log 2>&1
\end{verbatim}
      \item Discard output: \texttt{<cmd> > /dev/null}.
      \item Pipe \texttt{stderr}. Aim: discard \texttt{stdout} and pipe \texttt{stderr}. \href{https://stackoverflow.com/questions/2342826/how-can-i-pipe-stderr-and-not-stdout}{Actions}: redirect \texttt{stderr} to \texttt{stdout}, discard \texttt{stdout}, pipe.
\begin{verbatim}
cmd 2>&1 >/dev/null | pipe_receiver
\end{verbatim}
      \item \verb|>| can be used to write to file: \verb|echo "Hello world!" > hello.txt| will write into the provided file. If the file already exists it will be replaced, otherwise it will be created. If you want to \emph{append} to the file just use \verb|>>|.
      \item You may want to check out \texttt{tee} in \ref{sec:misc}.
    \end{itemize}
  \item Use braces (curly brackets) \verb|{ }| to save typing. Examples
    \begin{itemize}
      \item \verb|cp file_{orig,bkp}| expands to \verb|cp file_orig file_bkp|
      \item \verb|evince work{1,2,3}.pdf| expands to \verb|evince work1.pdf work2.pdf work3.pdf|
    \end{itemize}
  \item Manipulating strings:
    \begin{itemize}
      \item A quick \href{https://sookocheff.com/post/bash/bash-string-operators/}{guide}, or the official \href{https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html}{manual}.
      \item Extract substring: \verb|${string:position:length}|. For more details have a look \href{https://stackoverflow.com/questions/1405611/how-to-extract-the-first-two-characters-of-a-string-in-shell-scripting}{here}.
      \item Operator \verb|=~|: \verb|${string} =~ ${regex}| gives true if \verb|string| matches the provided regex syntax.
    \end{itemize}
  \item In a script, adding at the beginning \verb|set -e| will make the script exit immediately as soon as one of its commands finishes with a non-zero status (when it fails).
  \item For option management \verb|getopts| is recommended, see \autoref{sec:misc}.
  \item Arrays: have a look \href{https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays}{here}.
  \item For loops: have a look \href{https://www.cyberciti.biz/faq/bash-for-loop/}{here}.
  \item Notifications and dialogue windows: we really like the old-school terminal, but sometimes nice GUI stuffs and visual aides make life easier. Consider this: you launch a script which takes a really long time, so from the terminal you switch to do other stuff. It would be nice to be alerted when the said script finishes. I am still working on an audio signal, but consider these two options:
    \begin{itemize}
      \item \verb|notify-send "Title" "Body"|: a little notification pop-up
      \item More advanced: \verb|zenity|, Achieve notification, pop-up, interactive windows,\ldots Some stuff \href{https://renenyffenegger.ch/notes/Linux/shell/commands/zenity}{here}. Try \verb|zenity --<type> --text "Body"| where \texttt{type} can assume \texttt{notification}, \texttt{info}, \texttt{warning}, \texttt{error}, \texttt{text-info}, \texttt{progress}, \texttt{file-selection}, \texttt{list}, \texttt{entry}, \texttt{scale} and others. All but \texttt{notification} stop the flow of the script.
        \begin{itemize}
          \item Control the size with \verb|--width=<n>| and \verb|--height=<n>|
          \item \verb|--window-icon=/pat/to/icon|: choose an icon for your widget
          \item \verb|--timeout=<n>|: how long the widget should stay
        \end{itemize}
    \end{itemize}
  \item Aliases
    \begin{itemize}
      \item \item Pimp your \texttt{bash} by modifying the file \texttt{.bashrc} in your home (load modules that you want by default, set global variables,\ldots) and define personal shortcuts in \texttt{.bash\_aliases}, again in your home (verify that it is loaded in \texttt{.bashrc}).
      \item Preceding a terminal command with a backslash will tell the shell to run the command itself and not the alias with the same name if it exists.
      \item In \texttt{bash}, the keyboard combo \texttt{Ctrl+Alt+E} expands aliases and variables that you writing.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{valgrind}}
Some useful options:
\begin{itemize}
  \item Check and track memory leaks: \verb|--leak-check=full| \verb|--track-origins=yes|
  \item Log file: \verb|--log-file=<filename>|
  \item Reachable / possibly-lost: \verb!--show-reachable=yes|no --show-possibly-lost=yes|no!
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{gdb}}
\label{sec:gdb}
\begin{itemize}
  \item Calling functions such as \texttt{fabs}, \texttt{sin},...: \texttt{((double(*)(double))<foo>)(x)}
  \item Setting watchpoints which stay after the end of the current function:
\begin{verbatim}
  $ print pt
    (double *) 0x75e12
  $ watch *(double *) 0x75e12
\end{verbatim}
  \item Print all current variables: \texttt{info args} (try also \texttt{info locals})
  \item Logging output \href{https://sourceware.org/gdb/onlinedocs/gdb/Logging-Output.html}{here}
    \begin{itemize}
      \item Enable/Disable logging: \verb!$ set logging on|off!
      \item Change name of the log file (default is \texttt{gdb.txt}): \verb|$ set logging file <name>|
      \item Overwrite: \verb!$ set logging overwrite on|off!
      \item Redirect only to file: \verb!$ set logging redirect on|off!
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{git}}
\label{sec:git}
A nice, user-friendly introduction to \texttt{git} is available \href{https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud}{here}. And the official documentation is \href{https://git-scm.com/doc}{here}.

Intro: for those who do not know, \texttt{SHA1} is either the ID (long or short, it does not matter) of the commit, which one can get via a \texttt{git log}, or a tree-path relative to the \texttt{HEAD} (e.g.: latest commit=\texttt{HEAD}, second to last=\verb|HEAD^| or \verb|HEAD~1|, ($n+1$)-th to last=\verb|HEAD~n|). More info \href{https://git-scm.com/docs/git-cherry-pick}{here}.

For inexperienced users who want to perform simple tasks, such as looking at the changelogs and commit history, or creating commits, the user-friendly, GUI programs such as \texttt{git-cola} (manage the current status of your git repository) and \texttt{gitk} (looking at the commit tree and moving around it) are advisable.

\emph{Bonus.} This could seem totally unrelated, but, here is one the most visited question on \texttt{StackOverflow} (more than 2 million times!) which deals with \href{https://stackoverflow.com/questions/11828270/how-do-i-exit-the-vim-editor}{How to exit the \texttt{Vim} editor}. You may want to have a look at this question which has more than 8 million views and it is indeed \texttt{git}-related: \href{https://stackoverflow.com/questions/927358/how-do-i-undo-the-most-recent-local-commits-in-git}{How do I undo the most recent local commits in \texttt{git}?}

\begin{itemize}
  \item Run \verb|git| commands from another directory: \verb|git -C <path> <cmd>| (mnemonic: as in \verb|make|). Originally it was: \verb|--git-dir=<path> --work-dir=<path>|.
  \item \verb|git add <file_name>|: move the modifications in \verb|file_name| to commit stage (that is, they will be include in the next commit)
    \begin{itemize}
      \item The option \texttt{-p}, aka cherry-picking, splits the \verb|file_name| into chucks, so that you can choose which modifications are to be staged. For each of them, you will have to tell \texttt{git} what to do with it: if it is to keep, answer \texttt{y}; if not, \texttt{n}. Other answers are possible, for example use \texttt{s} (for split) reduce the chunk size / split the current chunk into sub-chunks. \href{https://stackoverflow.com/questions/1122210/can-i-modify-git-adds-hunk-size}{Here} you can find the meaning of all of the possible answers. This could be done easily with \texttt{git-cola}.
    \end{itemize}
  \item \texttt{git commit}: creates a new commit with the staged modifications. This operation is easily done in \texttt{git-cola}.
    \begin{itemize}
      \item \verb|-m "Commit title"|: a simple and fast way to create a commit;
      \item \texttt{-a}: all the modified files, even those which are not staged yet are added to the commit;
      \item Forgot a file in your last commit or want to modify it? \verb|git commit --amend| add the staged modifications to the last commit.
      \item Commit with the same message as the original (after a reset, or with the \verb|--amend| option): \verb|git commit -c ORIG_HEAD|.
    \end{itemize}
  \item For all merging-related commands (\texttt{am}, \texttt{merge}, \texttt{cherry-pick}, \texttt{rebase}, \verb|pull --rebase|...), if errors occur, you can use
    \begin{itemize}
      \item \verb|git <command> --continue|: the problems have been solved, tells \texttt{git} to continue what it was doing,
      \item \verb|git <command> --abort|: cancel the operation and return to the pre-sequence state, the situation before \texttt{git <command>} was called,
      \item \verb|git <command> --quit|: similar to \texttt{abort}, but do not reset the \texttt{HEAD} back to the original branch. The index and working tree are also left unchanged,
      \item \verb|git <command> --skip|: in some commands, e.g.~the \texttt{rebase}-related ones, skip (do not apply) the current commit, and continue.
    \end{itemize}
  \item \verb|git reset [options] SHA1|, \href{https://git-scm.com/docs/git-reset}{here}:
    \begin{itemize}
      \item \verb|--soft|, Does not touch the index or the working tree at all, but resets the \texttt{HEAD} to \texttt{SHA1},
      \item \verb|--mixed|, (default) Resets the index but not the working tree (the files do not change),
      \item \verb|--hard|, Resets the index \emph{and} the working tree;
    \end{itemize}
  \item \verb|git rebase -i SHA1|: (\texttt{-i} stands for interactive) enables to modify (delete, move up or down the log tree, fix up, squash, reword) the commits from \texttt{SHA1} to \texttt{HEAD};
  \item Modify an old commit (for which \verb|--amend| would not work): use a \texttt{rebase -i}
    \begin{itemize}
      \item For basic modifications: look \href{https://stackoverflow.com/questions/1186535/how-to-modify-a-specified-commit}{here};
      \item For splitting a commit or complex modifications: follow \href{https://stackoverflow.com/questions/6217156/break-a-previous-commit-into-multiple-commits}{here} (I suggest to \texttt{rebase} to one commit before the one you want to modify).
    \end{itemize}
  \item (Re)set the remote reference (from where git pulls) for the branch \verb|branch_name|
\begin{verbatim}
  git branch [<branch_name>] --set-upstream-to new_remote/branch_on_remote
\end{verbatim}
    If \verb|branch_name| is not provided, the current branch will be used as default;
  \item Working with remote repositories
    \begin{itemize}
      \item Getting the latest commits: \verb|git pull|. One may want to add the \verb|--rebase| option so that your non yet published commits stay on top of the tree.
      \item Publish the latest local commits: \verb|git push|. It is always better to do a \verb|git pull --rebase| before pushing in order to avoid conflicts.
      \item Damn! You have just pushed a commit and you realize just now that it needs an amend. Modify it in you local repository then force-push it, have a look \href{https://stackoverflow.com/questions/179123/how-to-modify-existing-unpushed-commit-messages}{here}.
    \end{itemize}
  \item Rename a branch:
    \begin{itemize}
      \item If on the branch to rename: \verb|git branch -m <new_name>|
      \item If on another branch: \verb|git branch -m <old_name> <new_name>|
    \end{itemize}
  \item \href{https://git-scm.com/docs/git-format-patch}{Create patches} from \texttt{SHA1} to most recent commit: \verb|git format-patch [options] <SHA1>|
    \begin{itemize}
      \item \texttt{-<n>}: create only \texttt{n} patches (always starting from \texttt{SHA1});
      \item \verb|--start-number <n>|: the patches are numbered starting from \texttt{n};
      \item \texttt{-N}: commits are unnumbered.
    \end{itemize}
  \item \href{https://git-scm.com/docs/git-am}{Apply a patch}: \verb|git am [options] path/to/patch|
    \begin{itemize}
      \item \texttt{-3}: if the patch does not apply cleanly for a certain file, falls back to the version of the most recent common commit between the current tree and the one coming with the patch, and propose a 3-way merge (current, patch, and ancestor),
      \item \verb|--reject|: when the application fails, tells \texttt{git} to apply as many modifications as possible and to temporarily skip the impossible ones. The rejected modification will be stored in \texttt{*.rej} files. The application has to be completed manually (you will have to personally modify the files)
    \end{itemize}
  \item \texttt{git log}: show the commit logs. \href{https://git-scm.com/docs/git-log}{Manual}
    \begin{itemize}
      \item \texttt{-<n>}, \texttt{-n <n>}: limit the number of commits to output
      \item \verb|--since=<date>|, \verb|--after=<date>|: show commits more recent than \texttt{date}
      \item \verb|--until=<date>|, \verb|--before=<date>|: show commits older than \texttt{date}
      \item \verb|-L <start>,<end>:<file>|: show commits which modified the zone of \texttt{file} delimited by the line numbers \texttt{start} and \texttt{end}
      \item \verb|-L:<function>:<file>|: show commits which modified function \texttt{function} of \texttt{file}
      \item \verb!--<path>|<path/to/filename>!: show commits which modified the files in \texttt{path} (resp.~the file \verb|path/to/filename|). To be put after all other options;
      \item \verb|--pretty[=<format>]|, \verb|--format=<format>|: customize the format of your output. You may want to choose predefined styles, then \texttt{format} can be chosen in \texttt{oneline}, \texttt{short}, \texttt{medium}, \texttt{full}, \texttt{fuller}, ...
    \end{itemize}
  \item Commit cherry-picking (\href{https://git-scm.com/docs/git-cherry-pick}{manual}): apply a specific commit from another branch
\begin{verbatim}
  git cherry-picking <commit>
\end{verbatim}
    \begin{itemize}
      \item Example: apply to the current branch the third-to-last commit of branch \verb|branch_name|:
        \begin{verbatim}
          git cherry-picking <branch_name>~4
        \end{verbatim}
    \end{itemize}
  \item Show config:
    \begin{itemize}
      \item Have a look at the global or local config file: \verb|~/.gitconfig| or \verb|repository/root/.git/config|
      \item List everything: \verb|git config [--global] --list|
      \item Specific key: \verb|git config [--global] --get <key_name>|
      \item Search: \verb|git config [--global] --get-regexp <pattern>|
    \end{itemize}
  \item Aliases: as for bash, one can create custom aliases to shortcut some common commands. In order to to that simply use
\begin{verbatim}
$ git config [options] alias.<shortcut> '<cmd>'
\end{verbatim}
        for instance
\begin{verbatim}
$ git config [--global] alias.pr 'pull ---rebase'
\end{verbatim}
  \item Proxy: some info are given \href{https://gist.github.com/evantoli/f8c23a37eb3558ab8765}{here}. Try to simply run (from wherever)
\begin{verbatim}
  $ git config --global http.proxy <server>:<port>
\end{verbatim}
  \item Ignore files from the syncing:
    \begin{itemize}
      \item Add them to \texttt{.gitignore}. Since \texttt{.gitignore} itself is synchronized, the exclusion is global and will stay in the tree, meaning that any new clone of the repository will see it;
      \item Add them to \texttt{.git/info/exclude}. This is local and impacts only the local directory and clone of the repository.
    \end{itemize}
  \item Push a new project to \href{https://github.com/}{GitHub} for the first time: follow \href{https://help.github.com/en/github/importing-your-projects-to-github/adding-an-existing-project-to-github-using-the-command-line}{this}.
  \item \texttt{git bisect}: help to find the commit causing the bug by a bisection procedure
    \begin{itemize}
      \item \verb|start|: initialize the procedure.
      \item \verb|bad [commit]|: tag commit as bad (default is current).
      \item \verb|good [commit]|: tag commit as good (default is current).
      \item \verb|reset|: once you have find the buggy commit, quit the procedure and go back to were you were at the beginning.
    \end{itemize}
  \item \verb|git grep| (\href{https://git-scm.com/docs/git-grep}{Manual}): as \verb|grep| (\autoref{sec:grep}) but on tracked files: \verb|git grep 'time_t' -- '*.[ch]'|. Some bonus options:
    \begin{itemize}
      \item Notice that \verb|--| marks the end of the options.
      \item \verb|--and|, \verb|--or|, \verb|--not|. Option \verb|-e| should be used.
    \end{itemize}
  \item Submodules: \href{https://git-scm.com/book/en/v2/Git-Tools-Submodules}{here}.
  \item Sometimes the \texttt{.git} directory (where all the \texttt{git} magic happens) is larger than the projects itself: imaging having to store all the commits, changes,\ldots{} \href{https://stackoverflow.com/questions/5277467/how-can-i-clean-my-git-folder-cleaned-up-my-project-directory-but-git-is-sti}{Here} you find how to do a little house-keeping. \verb|git gc| might be an option, as well.
  \item \href{https://git-scm.com/docs/git-filter-branch}{\texttt{git filter-branch}}: modify the tree according to filters.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{sed}}
Bases:
\begin{itemize}
  \item Some info could be found in the \href{https://www.gnu.org/software/sed/manual/sed.html}{manual} or in \href{http://www.grymoire.com/Unix/Sed.html}{this tutorial}; \href{https://www.tutorialspoint.com/unix/unix-regular-expressions.htm}{this} could be useful as well.
  \item A general knowledge of the regex could be very useful. Take a look at this \href{https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285}{chetsheet}
    \begin{itemize}
      \item \verb|^pattern|: matches any string that starts with \texttt{pattern}. \verb|pattern$|: matches any string that ends with \texttt{pattern}
    \end{itemize}
  \item General usage: \verb|sed [options] "[range] <command>" old_file new_file|. Double quotes \texttt{"..."} may be replaced by single quotes \texttt{'...'}.
    \begin{itemize}
      \item If no \verb|new_file| is given, the result is printed to \texttt{stdout}.
    \end{itemize}
\end{itemize}

Commands:
\begin{itemize}
  \item Common commands may be found \href{https://www.gnu.org/software/sed/manual/sed.html#Common-Commands}{here}, less common ones \href{https://www.gnu.org/software/sed/manual/sed.html#Other-Commands}{here}
  \item Search and replace:
\begin{verbatim}
  sed -i "s/<pattern>/<replaced>/" file
\end{verbatim}
  \item Replace all the lines matching \verb|pattern| with \verb|new_line| - this works on the entire line:
\begin{verbatim}
sed -i "/pattern/c\new_line/" file,
\end{verbatim}
  \item Delete all lines containing \verb|pattern| - this works on the entire line:
\begin{verbatim}
sed -i "/pattern/d" file;
\end{verbatim}
  \item Apply multiple commands at the same time:
    \begin{itemize}
      \item Separate them with semicolons: \verb|sed 'cmd1 ; cmd2' file|
      \item Separate them with \verb|-e|: \verb|sed -e 'cmd1' -e 'cmd2' file|
    \end{itemize}
\end{itemize}

Ranges: ranges are optional and it is the way to tell \verb|sed| to apply the provided commands only to those lines specified by the range. Some examples
\begin{itemize}
  \item \verb|4,10|: lines 4 to 10
  \item \verb|4,+6|: line 4 and the following 6 lines
  \item \verb|4,10!|: everything except lines 4 to 10
  \item \verb|4~3|: starting from line 4, every 3 lines
  \item \verb|/pattern/|: all the lines matching \verb|pattern|
\end{itemize}

Options and tricks:
\begin{itemize}
  \item The option \verb|-i[<suffix>]|, \verb|--in-place=[<suffix>]| allows to overwrite the file once it is modified. If \verb|suffix| is provided a backup is created with the chosen extension;
    \begin{itemize}
      \item \verb|-i.bak| creates a backup file,
      \item The option \verb|--follow-symlinks|, available only with \verb|-i| activated, enables to modify the original file;
    \end{itemize}
  \item If in one line there are more occurrences, only the first one is matched. Appending \texttt{g} will make \texttt{sed} match all the occurrences.
\begin{verbatim}
  sed -i "s/<pattern>/<replaced>/g" file
\end{verbatim}
  \item Character \verb|&| expands to matched string.
  \item Match exactly the word: from regex, \verb|\b| delimits boundaries of the word. Hence, (although \verb|\<word\>| seems to work, as well (\texttt{vim}, anyone?)):
\begin{verbatim}
$ echo "bar embarassment" | sed "s/\bbar\b/no bar/g"
no bar embarassment
\end{verbatim}
  \item Parentheses used in regex syntax (for groups \verb|(.)|, repetitions \verb|{.}|) should be escaped by a backslash: e.g. \verb|\(agroup\)|. Access groups content with \verb|\<n>| where \verb|n| is the number of the group. Or, add option \verb|-E|.
  \item Use \texttt{bash} variables: prefer the double-quotes \verb|"| instead of the single ones \verb|'|:
\begin{verbatim}
sed "s/${pattern}/${replaced}/" file
\end{verbatim}
  \item \verb|$| means last line when dealing with ranges, or end of the line when dealing with patterns.
  \item Mind that command \verb|d| erases the entire line, if you want to delete only the pattern, you can replace it with an empty string.
  \item Write at the beginning of the line: match the beginning (special character \verb|^|) and replace. For instance, in \texttt{C} comments all the lines containing \texttt{Comment} (mind that we have to escape character \verb|/|)
\begin{verbatim}
sed '/Comment/ s/^/\/\//' test.c
\end{verbatim}
  \item Replace only the first occurrence of \verb|pattern|: a bit tricky, find the right range (from line zero to first occurrence) then replace
\begin{verbatim}
sed '0,/pattern/ s/pattern/new pattern/' file
\end{verbatim}
  \item Replace only the last occurrence of pattern: I'm still working on that. A long and dirty workaround may be to use \verb|tac|, then replace \emph{first} occurrence and finally \verb|tac| again.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{grep}}
\label{sec:grep}
\verb|grep [options] <pattern> [files]|

Some useful options:
\begin{itemize}
  \item \texttt{-r}: recursive, then \texttt{files} can be a directory;
  \item \texttt{-R}: as above, but follow links;
  \item \texttt{-w}: match only complete \emph{w}ords;
  \item \texttt{-c}: just print the \emph{c}ount of the lines with a match;
  \item \texttt{-v}, \verb|--invert-match|: get lines with that do \emph{not} match the \texttt{pattern};
  \item \texttt{-e}, \verb|--regexp=<pattern>|: look for \texttt{pattern}. This can be used, for example if \texttt{pattern} starts with a dash (\texttt{-}); similar options are \verb!-E|F|G|P!
  \item \texttt{-i}, \verb|--ignore-case|: search is case-\emph{i}nsensitive;
  \item \texttt{-h}: without filename (mnemonic: \emph{h}ead)
  \item \texttt{-H}: with filename (mnemonic: \emph{H}ead)
  \item \texttt{-n}: show line number;
  \item \texttt{-m <n>}: print only the first \texttt{n} occurrences of the \texttt{pattern};
  \item \texttt{-B <n>}: print \texttt{<n>} lines \emph{B}efore the match (included);
  \item \texttt{-A <n>}: print \texttt{<n>} lines \emph{A}fter the match (included);
  \item \texttt{-C <n>}: print \texttt{<n>} lines of the \emph{C}ontext of the match;
  \item \texttt{-l}, \verb|--files-with-matches|: \emph{l}ist only the file names in which at least one match is found;
  \item \texttt{-L}, \verb|--files-without-matches|: \emph{L}ist only the file names in which no match is found;
  \item \texttt{-q}: \emph{q}uiet, return just the exit status code (0 or 1 corresponding to, respectively, true or false) according to whether it have found a match or not;
  \item \verb|--include=<pattern>|: consider only files matching \texttt{pattern}. For example for only \TeX{} sources
\begin{verbatim}
grep --include=\*.tex -r "O Bella Ciao" .
\end{verbatim}
  \item \verb|--exclude=<pattern>|: do not consider files matching \texttt{pattern};
  \item \verb|--exclude-dir=<dir>|: exclude files in directory \texttt{dir};
\end{itemize}

Tricks:
\begin{itemize}
  \item Start from the end: \verb!tac <files> | grep [options] <pattern>! (Add a pipe to \texttt{tac} to recover the original order).
  \item Print even if the match is not found \verb!grep -E '^|<pattern>' <file>!. Special character \verb|^| means "beginning of the line", hence it is always found. Why should one use it? with the option \verb|--color| (usually enabled by default) \verb|grep| highlights the matches. Here, the command find the beginning of the line, which cannot be highlighted, hence it prints the line, if it finds the pattern as well it will highlight it.
\end{itemize}

Types:
\begin{itemize}
  \item \texttt{-G}, \verb|--basic-regexp|, simple regexp, default
  \item \texttt{-E}, \verb|--extended-regexp|
  \item \texttt{-P}, \verb|--perl-regexp|
  \item \texttt{-F}, \verb|--fixed-strings|, exclude regexp
\end{itemize}

The version \texttt{zgrep} (with the same options) allows to search into compressed/\emph{z}ipped files.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{find}}
It allows to find files in a tree and apply a command to them:
\begin{verbatim}
  find [options] <path> <command>
\end{verbatim}
If no command is given, \texttt{-print} is executed. Some examples and options:
\begin{itemize}
  \item Check if file \texttt{filename} is in \texttt{mydir} or one of its subdirectories (\texttt{-print} is considered, thus it works similarly to \texttt{ls})
\begin{verbatim}
  find <mydir> -name <filename>
\end{verbatim}
  \begin{itemize}
    \item \verb|-regex|: similar to \texttt{name} but one can use regex syntax to write the pattern. The type can be chosen with \verb|-regextype| (ex. \texttt{sed}). Notice that \texttt{find} always prepends \verb|./| to the path so you may want to start your pattern with something like \verb|.*/|
    \item Case-insensitive search: use \verb|-iname| or \verb|-iregex| as you would use their parent options
  \end{itemize}
  \item Filter on the file type: option \verb|-type <t>| where \texttt{<t>} can be, for example, \texttt{d} (directory), \texttt{f} (regular file), \texttt{l} (symbolic link)\dots
  \item \texttt{!}, \texttt{-not}: negation of the expression that follows. E.g.: \texttt{find . -not -name foo} print all the files in the current directory with a name different than \texttt{foo}.
    \begin{itemize}
      \item Exclude a path:
\begin{verbatim}
find . -name notmyfile -not -path <dir_excl>
\end{verbatim}
        This is somehow too simple and \texttt{find} will still search into the sub-directories of \verb|dir_excl|. You may find other solutions \href{https://stackoverflow.com/questions/4210042/how-to-exclude-a-directory-in-find-command}{here} (the accepted answer with \verb|-prune|may not always work).
    \end{itemize}
  \item \verb|-maxdepth <n>|: limit the tree descent level of the search
  \item Apply a command to all the matching files: e.g.~run a bash script, grep only certain files
\begin{verbatim}
find . -name *.log -exec script.sh {} \;
find . -name *.log -exec script.sh {} +
find . -name *.log -exec grep -Hn --color "pattern" {} +
\end{verbatim}
\verb|{}| stands for the matching files; the first version will execute as many calls as the numbers of matching files, the second (tries to) appends all the files in an single list of arguments (hence saving the calls to the script)
  \begin{itemize}
    \item Mind that \texttt{find} does not know the content of \texttt{.bashrc} and alike, hence one could not use aliases (its \texttt{ls} command might be stripped-down with respect to what one is used to, you may want to consider adding some user-friendly options).
  \end{itemize}
  \begin{itemize}
    \item \verb|-ok|: like \texttt{exec} but ask the permission first
    \item \verb|-execdir|: like \texttt{exec} but run the command from the subdirectory that contains the matched file.
  \end{itemize}
  \item Delete all the matching files: e.g.~delete all the \texttt{.log} files \texttt{find . -name *.log -delete}
    \begin{itemize}
      \item \texttt{-delete} calls \texttt{rm} under the hood, in fact it is practically equivalent to \texttt{-exec rm}. Hence it will fail if one tries to delete directory. In this case, use the long way: \verb|-exec rm -r {} \;|. You may add \verb|-prune| to avoid some warnings/errors. Moreover, one may add quote around braces to avoid errors with names that contains whitespaces.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compressing: \texttt{tar} \& \texttt{zip}}
\texttt{tar} is a utility which creates archives
\begin{itemize}
  \item Basic usage:
    \begin{itemize}
      \item \verb|c|, \verb|-c|, \verb|--create|: create. Remember to put all the files that you want in your archive in one go.
\begin{verbatim}
tar -cf archived.tar file/to/archive
\end{verbatim}
      \item \verb|x|, \verb|-x|, \verb|--extract|, \verb|--get|: extract
\begin{verbatim}
tar -xf archived.tar
\end{verbatim}
      \item As you have already understood, \verb|-f| stands for file(name).
    \end{itemize}
  \item Additional options:
    \begin{itemize}
      \item Zip (compress), \verb|-z|: use compression algorithms. The option has to be used also when extracting compressed archived. Usually, compressed archived have \verb|.tar.gz| or \verb|.tgz| as extension.
      \item \verb|t|, \verb|-t|, \verb|--list|: list the files.
      \item \verb|r|, \verb|-r|, \verb|--append|: add files to an existing archive.
      \item \verb|u|, \verb|-u|, \verb|--update|: add to the archive only the files which are already present and which have been modified.
      \item \verb|A|, \verb|-A|, \verb|--catenate|, \verb|--concatenate|: concatenate archives.
      \item Symbolic links: by default, \texttt{tar} keeps the links. If in the archive one wants a \emph{copy} of the \emph{original} file to which the link points to, option \verb!-h|--deeference! should be used.
    \end{itemize}
\end{itemize}

\medskip
A cross-platform extension for compressed files is \texttt{zip}. To compress simply run
\begin{verbatim}
zip [options] <compressed_file>.zip <files_to_compress>
\end{verbatim}
By default it adds links as hard-files (and not as links). Option \verb|-r| (mneno: \emph{r}ecursive) include also {sub}directories and their files.

To deflate, run \verb|unzip <compressed_file>.zip|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{awk}}
\label{sec:awk}
\texttt{awk} is a text-processing utility that allows to perform easily operations line-by-line with column (here called \emph{fields}) manipulations. A tutorial is given \href{https://www.tutorialspoint.com/awk/index.htm}{here}.
\begin{itemize}
  \item Basis: \verb|awk [opt] 'BEGIN{[...]} {[...]} END{[...]}' <file>|
    \begin{itemize}
      \item The commands in the curly brackets after \texttt{BEGIN} are executed before starting the reading of the file,
      \item The commands in the unnamed curly brackets are executed at each line,
      \item The commands in the curly brackets after \texttt{END} are executed once the file has been read,
      \item Each of these three sections is optional;
    \end{itemize}
  \item A conditional statement (called \emph{pattern}) may be put just before the unnamed braces. Binary operations or comparisons can be used. If present, the commands inside are applied only to the rows verifying the pattern; if not, to all the rows. E.g.
    \begin{itemize}
      \item print the third row: \verb|awk 'NR==3{print;exit}' file.txt|
      \item print lines containing \texttt{apple}: \verb|awk 'BEGIN{print "We eat an"}/apple/' file.txt| (print is implied)
      \item More than one pattern might be used. No particular syntax is needed: nothing, a space or a newline will do the trick
\begin{verbatim}
awk '/apple/{print "Found an apple"}/banana/{print "Found a banana"}' infile
\end{verbatim}
    \end{itemize}
  \item Select the \texttt{n}-th field \verb|$<n>|. Remark: it is 1-based (first field is indexed by 1), and \verb|$0| expands to the whole line.
  \item Printing: it is usually achieved by command \texttt{print}. Some notes
    \begin{itemize}
      \item Columns are accessed with a dollar \verb|$|, for variables just use their name
\begin{verbatim}
awk '{print $NF}' file # Print last column only
awk -v T=8 'END{print "2 times T = " 2*T}' file
\end{verbatim}
      \item One can use redirection such as \verb|>|, \verb|>>| as explained in \autoref{sec:shell} to write to file. E.g.
\begin{verbatim}
awk 'BEGIN{print Ciao > "ciao.txt"}' file
\end{verbatim}
      \item \texttt{print} it also prints a new line stamp at the end
      \item \texttt{printf}, very similar to the \texttt{C} function, it can be used to choose the format. Differently from \texttt{print}, it does not insert a new line. E.g. (mind the \verb|\n|)
\begin{verbatim}
awk '{printf "I want %5.2f bananas\n" 1.652}' file
\end{verbatim}
    \end{itemize}
  \item Useful options:
    \begin{itemize}
      \item The file name is given as argument of the command or with \verb|-f <file>|, or \verb|--file=<file>|.
      \item \verb|-F <char>|, \verb|--field-separator="<char>"|: \verb|char| is the column separator (space is default);
      \item Pass an argument: \verb|-v var_name=<value>|
      \item When using \texttt{gawk} (the GNU implementation of \texttt{awk}) one can asks for in-place replacement: \verb|-i inplace|.
    \end{itemize}
  \item Built-in variables:
    \begin{itemize}
      \item \verb|NF|: number of fields / columns in the current row (hence \verb|$NF| is the last column of the row)
      \item \verb|NR|: row number, mind that it is incremented if several files are read (1 based).
      \item \verb|FNR|: row number relative to current file. It resets to 1 every time a new file is read.
      \item \verb|FS|: field separator
      \item \verb|FILENAME|: should I explain?
      \item \verb|ENVIRON|: array with environment variables (e.g.~try \verb|ENVIRON["USER"]|).
    \end{itemize}
  \item Tricks:
    \begin{itemize}
      \item \href{https://www.gnu.org/software/gawk/manual/html_node/String-Functions.html}{String-Manipulation functions}
      \item Operator "match", \verb|~| (tilde): \verb|<string>~<pattern>| true if \verb|string| matches \verb|pattern|. The negation is \verb|!~|. Hence, the following emulates \texttt{grep }(well, not exactly since we search in the second column only, but you get the idea)
\begin{verbatim}
awk '$2~/<pattern>/{print $0}' file.txt
\end{verbatim}
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{C}}
\label{sec:c}
Just some tricks.
\begin{itemize}
  \item ATTENTION - Memory management. To some pointers and functions related to them such as \texttt{malloc}, \texttt{realloc} and \texttt{free}, are some of the most confusing things about \texttt{C}. Here, I do not pretend to explain everything, but let me tell you this, which should be a golden rule for developing in \texttt{C}: for every \texttt{malloc} that you call, remember to call also its related \texttt{free}. The impact of non-freed memory may be insignificant on certain problems, but it could quickly snowballing into something really dangerous and crash the run.
  \item It is advised by someone to use preprocessor false statements as a comment zone in which one can put anything (s)he wants to
\begin{verbatim}
#if 0
  This part won't be seen by the preprocessor
  Anything you want, no special caratchers needed
  Although some warning may be issued, for instance for unbalanced parantheses
#endif
\end{verbatim}
  \item Operator \verb|?|: it is a shortcut for a simple \texttt{if} statement.
\begin{verbatim}
  /* binary condition */ ? /* if true, do this */ : /* otherwise, do this */
\end{verbatim}
    For instance it could be useful when one wants to define a \texttt{const} variable which however depends on a certain condition.
\begin{verbatim}
  const int max = (n > m) ? n : m;
\end{verbatim}
    Notice that in this case, if \verb|m| or \verb|n| are calls to functions, they are evaluated twice, one for the comparison, and one for the assignment. Hence, if the calls are time-consuming, you might want to use temporary variables.
  \item \href{https://www.improgrammer.net/type-casting-c-language/}{Casting}: it is a way to change the type of a variable.
    \begin{itemize}
      \item Sometimes it is hidden: \verb|float a = 1;|. Because of its format, \verb|1| is actually interpreted as an integer and then cast into a floating-point number.
      \item Casting could be done explicitly:
\begin{verbatim}
old_type a = [...];
new_type b = (new_type)a;
\end{verbatim}
      \item The compiler will always try to cast, but if there is no correlation between the two data types unexpected behaviour and loss of precision may happen. Consider for instance
\begin{verbatim}
float a  = 1.1;
int   ab = (int) a;
\end{verbatim}
    \end{itemize}
  \item Memory / arrays tricks
    \begin{itemize}
      \item Fastest (?, possibly if one runs sequentially) to reset an array:
\begin{verbatim}
memset(dest, 0, dest_len*sizeof(<dest_type>))
\end{verbatim}
        (destination, value to copy, number of bits to consider). Notice that since it works on the single bits, this works only with zero, namely that would not work to fill an array with ones (or any value, indeed). Mnemonic: \verb|dest = 0|.
      \item Fastest (?, possibly if one runs sequentially) to copy an array into another: structure similar to the one above. Mnemonic: \verb|receive = send|
\begin{verbatim}
memcpy(receive, send, <n_element_to_copy>*sizeof(<send_type>))
\end{verbatim}
    \end{itemize}
  \item Booleans:
    \begin{itemize}
      \item Originally, \verb|0| means false and \verb|1| (well, actually, any integer different than zero) means true.
      \item Since \verb|C99|, the type \verb|_Bool| is introduced.
      \item The standard library \verb|stdbool.h| introduces \verb|bool| (which expands to \verb|_Bool|), \verb|false| (expands to \verb|0|) and \verb|true| (expands to \verb|1|).
    \end{itemize}
  \item Loops:
    \begin{itemize}
      \item \texttt{break} exits the innermost loop only (\texttt{for} or \texttt{while}). If one wants to exit all of them, a flag (a \verb|_Bool|/\verb|bool|) should be used.
      \item \texttt{continue} skips the rest of the current iteration, increases the counter and goes to the next iteration (stays in the loop!)
    \end{itemize}
  \item File reading/writing: \href{https://www.programiz.com/c-programming/c-file-input-output}{here}.
  \item Preprocessor
    \begin{itemize}
      \item Compile with \verb|-E| to get the source file preprocessed.
      \item \href{https://gcc.gnu.org/onlinedocs/gcc-7.5.0/cpp/Stringizing.html}{\emph{Stringizing}}
        \begin{itemize}
          \item Macro to make something a string, use \verb|#|: \verb|#define str(s) #s|
          \item Double it if you want to make the content of another macro a string
\begin{Verbatim}[samepage=true]
#define foo 4.0
#define str(s)  #s
#define xstr(s) str(s)
// Now use xstr(foo) -> "4.0"
\end{Verbatim}
        \end{itemize}
      \item Append / Concatenate: use operator \verb|##|. Consider this\footnote{Did you actually believe that \href{https://hitchhikers.fandom.com/wiki/42}{42} was not going to appear here?! You fool!}
\begin{Verbatim}[samepage=true]
float pow2(float x){return x*x;}
float pow3(float x){return x*x*x;}
#define _p(a,b) pow##b(a)
[...]
float var = 42.;
float var_square = _p(var,2); // Expands to pow2(var)
float var_cube   = _p(var,3); // Expands to pow3(var)
\end{Verbatim}
    \end{itemize}
  \end{itemize}
\subsection{Poorman optimizations}
  Here are some simple optimizations that you can consider, you can think of them as good practices. They won't certainly have much of an impact on the total runtime (in fact, especially with the loops, the compiler will try do anticipate what you want to do and optimize it), but it is useful to have them in mind and of course, it is definitely better to use them. A great deal of them deals with cache optimizations and avoiding cache-misses, it could be interesting to have a look at how a cache is and works and how to get the most out of it. Anywho, here are some optimizations:
    \begin{itemize}
      \item Constant variables. You need to define a variable and you know for sure from the beginning that its values will not change in the current scope. It is then advisable to define them as constant: the compiler will take into consideration this piece of information and use it to optimize the program. In order to make a variable constant, just prepend \texttt{const} to the usual definition \texttt{const int n = 10;}. You try to modify a value of a constant value, you'll get an error or at least a warning. You can also make the arguments of a function constant, this may be beneficial in three ways: optimization, allow the user to identify input and output parameter, and avoid error like modifying a value that you are not supposed to. However, it is usually not advised to make an argument of a function constant if it's one value (\texttt{int}, \texttt{float},\ldots) since in this case the performance gains will be null. Still it could be beneficial for the lecture.
      \item Data locality: try to define variables as close as possible to where you are going to use them. Basically, it is sometimes better to redefine a variable in a loop at each iteration rather than define it outside and change it at each iteration.
      \item Array accessibility. Somehow related to the previous point, you are looping through a huge array with hundreds or thousands of elements. If you are going to use the value several times, redefine a pointer that points just the current item. For instance,
\begin{verbatim}
for (int i=0; i < 10000; i++){
  double *a_i = a + i;
  // use now a_i[0]
}
\end{verbatim}
        This can be pretty useful if you are dealing with coordinates, for instance
\begin{verbatim}
for (int i=0; i < 10000; i++){
  double *a_i = a + 3*i;
  // a_i[0] will be the x-coordinate of the i-th point
  // a_i[1] the y one and a_i[2] the z one
}
\end{verbatim}
        Why that? Well, it actually takes some time to move in the memory to recover a value so accessing \texttt{v[1]} is (slightly) faster than \texttt{v[1000]}, having to doing it several thousands of times may impact the performances.
      \item Prefer arrays to matrices: using \verb|a[i][j]| is convenient but if the dimensions are large is pretty slow, the reason is somehow related to the previous item. Anyway, the bottom line is: A unique array is much faster: \verb|a[n_cols*i+j]| (if you have to choose only one optimization to remember, choose this one, big times)
      \item Prefer looping by columns rather than by rows. Another tips about memory and matrices, the reason of it is the cache: when the computer access a location in the memory, it also loads some chunks of memory that are just next to the one it actually needs, In this way, if it will need this additional piece of memory in the next iterations (as it is often the case), it already has it and avoid loading it thus saving some time. When looping by rows, the data that we request are (often) too far away from each other and a load at each iteration is almost certain. Bottom line: (notice the switch of the indexes and, most importantly, which loop is the innermost) this
\begin{verbatim}
for (int i=0; i < n_rows; i++)
  for (int j=0; j < n_cols; j++)
    a[i*n_cols+j] *= 2;
\end{verbatim}
        is better than
\begin{verbatim}
for (int j=0; j < n_cols; j++)
  for (int i=0; i < n_rows; i++)
    a[i*n_cols+j] *= 2;
\end{verbatim}
      \item Loop unrolling. Well, that is almost useless since the compiler will sometimes try do it even without being asked. However, a \texttt{for} loop has an overhead. So if it is not much of a fuss, you can try to write yourself by hand the iterations. Again, nowadays loop unrolling is practically useless but it is interesting to know how things work.
      \item Keep loops as straight as possible. The compiler will try to guess what the next operation will be, try to (almost) perform consecutive iterations at the same time, load some memory which is adjacent to the one you are requesting,\ldots{} you get the idea. If it does not manage, the program has to do unload what it thought and load what you really asked, and that takes time. Hence, avoid \texttt{if} statement in loops as much as possible, avoid jumping around an array, basically keep a straight path.
      \item Short types. Sometimes you know that a certain variables will not exceed a threshold, you can then using short types, which takes less memory than standard types. For instance, looping through the components of a vector, use \texttt{short int}
\begin{verbatim}
for (short int i=0; i < 3; i++){
  // Do something
}
\end{verbatim}
        (You may wonder, so why not use it all the times? Well, the maximum number that a short integer can represent is not that much and you may never reach the bound of the loop)
      \item Inline function. If a function is less than a dozen line long, consider inlining it. If this concept is new to you, know that: he code of an inline functions is copied as is where it is requested, so that by using inlined functions we don't get the overhead for the call to a function. Calling a long inlined function many times makes the executable larger (many lines of code) and that is something to avoid, hence, a dozen lines is a good thumb-rule.
      \item If dealing with synchronization in parallel mode, try to call those functions as less as possible. Instead of doing \texttt{n} times a synchronization of a vector of 3 values, prefer only one synchronization of a vector of \texttt{3*n} values.
    \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\texttt{OpenMP}}
\texttt{OpenMP} or \texttt{OMP} is a shared-memory interface for \texttt{C}/\texttt{C++} (and \texttt{Fortran} as well) for parallel computing. \emph{Shared-memory}, simply put, means that the memory may be accessed, read, and modified by any thread at any given moment. Most of the times, parallelize a piece of code with \texttt{OMP} comes down to prepend dedicated pragmas (\verb|#pragma omp [...]|) to \texttt{for} loops (the last two sentences were \emph{very} wrong, but it might get you on the right direction if this is the first time you have heard of parallelism and \texttt{OMP}). Now that you have the bigger picture and you are thinking "Well, that was easy, I can do it!", welcome to the hardest part, where not so rarely you have to change your piece of code in order not to have threads modifying each other's work.
  \begin{itemize}
    \item A nice training is available on the IDRIS \href{http://www.idris.fr/formations/openmp/}{website}.
    \item A \href{https://www.openmp.org/wp-content/uploads/OpenMP-4.0-C.pdf}{cheat-sheet} (for version 4.0).
    \item Unless dedicated instruction are provided (see a couple of items below), every line of code inside a parallel zone is executed by \emph{all} the threads.
    \item A killer feature is the \texttt{reduction}s: compute sums, find max/min, or any operation you'd like (as long as you define it).
    \item This is something that is true generally for any parallel framework not only \texttt{OMP}: parallel code and I/O operations (reading/writing) can become tricky pretty easily, be advised (Remember: several threads working on the same thing? Too many cooks spoil the broth).
    \item It is important to have in mind which commands are \emph{blocking}, meaning that have a hidden barrier at the end (a point at which all the threads have to meet before they are allowed to continuing the execution of the program). For instance, \verb|#pragma omp [parallel] for| is blocking (however, keep in mind the \verb|nowait| clause).
    \item Sometimes one need that one thread only may work on something at the same time. This is where \verb|#pragma omp critical| and \verb|#pragma omp atomic| come into play, where the last one provide better performances but allows only very few operations like reading, writing, and updating (e.g. \verb|sum += a[n];|).
    \item In parallel mode but this particular piece of code should be executed once and once only? Put it in dedicated pragmas like \verb|#pragma omp master| (only the master thread, usually the one with ID 0, is allowed to execute the code) or with \verb|#pragma omp single| (only the first threads arrived at that point executes it, this is your best choice most of the times). They have no barriers.
    \item Just to get it right, let us recap the difference between the last two points. With \texttt{critical} or \texttt{atomic} all the threads execute the command, but one at the time. With \texttt{single} or \texttt{master} the code is executed only once.
  \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{python}}
\label{sec:python}
(I used to be better with \texttt{python} but I don't use it so much now, so these tips here are not many nor much useful. I'm sorry. If you agree, please contribute!)
\begin{itemize}
  \item Debugging, info \href{https://docs.python.org/2/library/pdb.html}{here}: \texttt{python -m pdb script.py}.
    Commands are similar to \texttt{gdb} (\ref{sec:gdb}).
  \item \texttt{pip}: allows you to download and update python libraries
    \begin{itemize}
      \item Typical call: \verb|pip install <package>|. Add options \verb!--upgrade|-U! to upgrade.
      \item You'll need access to some directories, thus it is advised to have a local install: pass option \verb|--user|.
      \item Proxy: pass the option \verb|--proxy=user@server.dom:port|.
      \item Get list of outdated packages: \verb|pip list --outdated|.
      \item When installing/upgrading problems may occur with older versions of the \texttt{C} compiler, \texttt{GCC}: try and force \texttt{C99} standard by setting \texttt{CFLAGS} before installing: \verb|export CFLAGS='-std=c99'|
    \end{itemize}
  \item \texttt{matplotlib}
    \begin{itemize}
      \item \texttt{matplotlib.ion()} switch the interaction with the plot on, so that \texttt{plt.plot()} is not blocking and the plot can be kept and redrawn multiple times. This of course works in a plot environment, if you use it on a script the plot will disappear as soon as the script reaches its end.
      \item 3D plots. A nice introduction can be found \href{https://jakevdp.github.io/PythonDataScienceHandbook/04.12-three-dimensional-plotting.html}{here}. To activate 3D-plotting (scatter, surface, mesh plot or any other) the axis should be called with \lstinline[language=python]{projection='3d'} which should be imported as follows: \lstinline[language=python]{from mpl_toolkits import mplot3d}
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{markdown}}
\begin{itemize}
  \item \texttt{markdown} files are usually used for \texttt{README} and such.
  \item Common extension: \texttt{.md}, \texttt{.markdown}
  \item Compile them with \texttt{pandoc} in order to get an \texttt{html}, for instance, that you can open with a browser.
\begin{verbatim}
pandoc --from=markdown --to=html -o out.html in.md
\end{verbatim}
  \item Guides, cheat-sheet and tutorial:
    \href{https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet}{\texttt{Git-Hub}-flavoured}, \href{https://daringfireball.net/projects/markdown/syntax#list}{official}, quick \href{https://commonmark.org/help/}{cheat-sheet} and a \href{https://agea.github.io/tutorial.md/}{tutorial}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{gnuplot}}
\begin{itemize}
  \item Keep the plot-windows open after closing the platform / having run the script: \verb|gnuplot --persist|
  \item Basic plotting from file: e.g.~use column 1 as x and 3 as y (mind \texttt{u} is equivalent to \texttt{using})
\begin{verbatim}
  plot "file.dat" using 1:2 [options], "file2.dat" u 1:3
\end{verbatim}
\end{itemize}
Useful options:
\begin{itemize}
  \item \verb!linecolor|lc!: e.g. \verb|lc "black"|. For more advance setting: \verb|linetype rgb "<parameters>"|
  \item \verb!with|w!: lines and marks \verb|linespoints|, lines/marks only \verb!lines|points!
  \item \verb|title "<legend_entry>"|
  \item \verb!linewidth|w!
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Miscellaneous}
\label{sec:misc}
\begin{itemize}
  \item \texttt{echo}: print a line to standard output. E.g. \verb|echo "Ciao World"|. It includes a newline at the end. It could be used via piping to provide an input parameter to a command.
    \begin{itemize}
      \item Variables can be used. Suppose you have \verb|what="cute puppy"|, then one can use
\begin{verbatim}
echo "I want a ${what}"
\end{verbatim}
      \item For redirection to files have a look at \autoref{sec:shell}.
      \item \verb|-n|: do not to insert a new line at the end.
      \item \verb|-e|: interpret a backslashed character, e.g. \verb|\n| will be considered as newline
      \item Overwrite: use \verb|\b| (needs option \verb|-e|) to go back a character. For entire lines, have a look \href{https://stackoverflow.com/questions/11283625/overwrite-last-line-on-terminal}{here}.
    \end{itemize}
  \item Download with command line: \texttt{wget} and \texttt{curl}
    \begin{itemize}
      \item Basic stuff \href{https://linuxconfig.org/download-file-from-url-on-linux-using-command-line}{here}
      \item With proxy \href{https://www.cyberciti.biz/faq/linux-unix-curl-command-with-proxy-username-password-http-options/}{here}
    \end{itemize}
  \item Send email from terminal (because, why not. And yes, I have tried it in order to transfer a file from the cluster to my machine): look \href{https://www.tecmint.com/send-email-attachment-from-linux-commandline/}{here}, a quick \href{https://www.interserver.net/tips/kb/linux-mail-command-usage-examples/}{tutorial}.
\begin{verbatim}
  echo "Message Body Here" | \
      mailx -s "Subject Here" -a attachment.txt user@example.com
  echo "Message Body Here" | \
      mail -s "Subject Here" -A attachment.txt user@example.com
\end{verbatim}
  \item \texttt{PETSc} \href{https://www.mcs.anl.gov/petsc/petsc-current/docs/manual.pdf}{manual}
    \begin{itemize}
      \item Use \verb|MatView(Mat a, PETSC_VIEWER_DRAW_WORLD)| or with any another \texttt{PetscViewer} to draw the nonzero structure of a matrix.
    \end{itemize}
  \item \texttt{wc}: \texttt{shell} command to perform some basic counting operations on a file (mnemonic: \emph{w}ord \emph{c}ount):
\begin{verbatim}
wc [options] <file>
\end{verbatim}
    \begin{itemize}
      \item \verb|-c|: print number of bytes;
      \item \verb|-w|: print number of words;
      \item \verb|-l|: print number of lines;
      \item \verb|-m|: print number of characters;
      \item \verb|-L|: print max line length;
      \item It usually (at least with \verb|-l|) re-prints the file name. To avoid use: \verb|wc -l < file.txt| (notice \verb|<|);
    \end{itemize}
  \item \texttt{test} or operator \verb|[| (square brackets): test if an expression is true. A quick \href{https://www.computerhope.com/unix/test.htm}{guide}. But the \texttt{man} page is clear and concise, just use this one.
  \item \verb|touch <file>|: modify the file access and/or modification date. If the file doesn't exist, an empty one will be created (unless specific options are given). For more details and all the options, have a look at its \texttt{man} page.\\
  Why should one use it?
    \begin{itemize}
      \item Changing the modification date of a file will force a smart compiler such as \verb|make| to re-run the compilation.
    \end{itemize}
  \item \href{http://www.imagemagick.org/script/convert.php}{\texttt{convert}}: very powerful tool for manipulating images (part of the \href{https://imagemagick.org/index.php}{\texttt{image magick}} suite, some \href{http://www.imagemagick.org/script/command-line-processing.php}{tips})
    \begin{itemize}
      \item Convert: \verb|convert test.<ext1> test.<ext2>| the extension can be \texttt{pdf}, \texttt{jpg}, \texttt{png},\ldots
      \item Rotate: \verb|-rotate <deg>|
      \item Choose density|quality (and hence the final size): option \verb|-density <n>| (its unit is \texttt{dpi})
    \end{itemize}
  \item \href{https://github.com/DavidFirth/pdfjam#using}{\texttt{pdfjam}}: nice and easy utility to modify \texttt{pdf} files
    \begin{itemize}
      \item Extract and/or merge
    \end{itemize}
\begin{verbatim}
pdfjam [options] -- file_1.pdf ['<page_range>'] [file_2.pdf ['<page_range>'] ...]
\end{verbatim}
    \begin{itemize}
      \item Rotate: Commands specified for certain angles are available: \verb!pdf90|180|270 <in.pdf>!
    \end{itemize}
  \item Job management:
    \begin{itemize}
      \item \verb|pgrep [options] <pattern>|: print info, especially the job-IDs, of all the jobs matching \verb|<pattern>|. Option \verb|-l| lists the names as well (and not only the IDs).
      \item \verb|kill [options] <job_ID>|: kill (send \texttt{SIGTERM} to) the job denoted by \verb|<job_ID>|.
      \item \verb|pkill [options] <pattern>|: as \verb|kill| but looks for matches in job names before (as \verb|pgrep|).
    \end{itemize}
  \item \verb|[h]top|: \verb|top| (and its user-friendly version \verb|htop|) gives an overview of a running system. One can find, for instance and just to name the most useful features, which jobs are running and how much memory or processors are used.
    \begin{itemize}
      \item Filter: use option \verb|-p <ID>|. Using the job name instead of the ID is more convenient: have a look at \href{https://unix.stackexchange.com/a/347544}{this}: \verb|top -p `pgrep -d "," <name>`|.
    \end{itemize}
  \item \texttt{du}: shows the space used by the directories (and files) (mnemonic: \emph{d}isc \emph{u}sage)
    \begin{itemize}
      \item \verb!-a|--all!: show the space of every files, not only the directories
      \item \verb!-h|--human-readable!: use convenient units (MB,GB,\ldots)
      \item \verb!-d|--max-depth=<n>!: how many levels down the directory-tree \texttt{du} should search
      \item \verb|--exlude=<pattern>|: well, I think you get it
    \end{itemize}
  \item \texttt{df}: check disk space info about the system (mnemonic: \emph{d}isk \emph{f}ree / \emph{f}ilesystem)
  \item \texttt{time}: run programs and summarize system resource usage (from \texttt{man}). \verb|time my_script.sh|; get the execution time of the script. More insight \href{https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1/556411#556411}{here}.
  \item \texttt{uname}: print system info
  \item Con\emph{cat}enate files and print to standard output (basically print the content to screen)
    \begin{itemize}
      \item \verb|cat [<opt>] file [file2 [...]]|
      \item \verb|tac [<opt>] file [file2 [...]]| as above but reverse order of the lines
    \end{itemize}
  \item \verb|cp [source] [dest]|: copy \texttt{source} into \texttt{dest}
    \begin{itemize}
      \item \verb|-t|: target. \verb|cp -t dest -- [source]| is equivalent to \verb|cp [source] [dest]|
      \item \verb|-r|: recursive, useful for directories
      \item \verb|-u|: copy only if there is no file with the same name in \texttt{dest} or if \texttt{source} is newer
      \item \verb|-p|: preserve mode, ownership, and time-stamps
    \end{itemize}
  \item \verb|crontab|: job scheduling. It allows one to regularly run some commands or scripts. Tutorial \href{https://www.adminschoice.com/crontab-quick-reference}{here} or \href{https://www.computerhope.com/unix/ucrontab.htm}{here}.
  \item \texttt{tee}: read from standard input and write to standard output \textbf{\&} files. Useful when you want to save the output of a command to file but you still want to read it on screen. E.g.
\begin{verbatim}
  echo "This'll be printed to screen and inside file.txt" | tee file.txt
\end{verbatim}
    \begin{itemize}
      \item \verb|-a|: append to file.
      \item Print to screen \& pipe: \verb!./script | tee /dev/tty | ./script_with_pipe!
    \end{itemize}
  \item \texttt{bc}: shell calculator (mnemonic: \texttt{b}asic \texttt{c}alculator)
    \begin{itemize}
      \item Some examples \href{https://www.geeksforgeeks.org/bc-command-linux-examples/}{here}.
      \item How to
        \begin{itemize}
          \item Simply run \texttt{bc} and an interactive interface will open (similar to what you get when you run \texttt{python}). Type \texttt{quit} for\ldots yeah, quitting.
          \item If you do not need extensive calculation but have just a one-liner expression, just pass it to \texttt{bc}: \verb!echo "20+5" | bc! or \verb|bc <<< "20+5"|
        \end{itemize}
      \item Operators like \verb|++|, \verb|*=|, etc.~are accepted
      \item Give option \verb|-l| to load the standard math library and, for instance, deal with floating point calculation and use standard functions (e.g.~sine \verb|s(x)|).
    \end{itemize}
  \item \texttt{tr}: \emph{tr}anslate, squeeze and/or delete characters from standard input. Basically performs string operations on standard input. Some options and examples
    \begin{itemize}
      \item \verb!echo Maaan | tr a e!: change \texttt{a}'s into \texttt{e}'s, hence the result is \texttt{Meeen}.
      \item \verb|-d|: \emph{d}elete. \verb!echo Maaan | tr -d a! gives \texttt{Mn}
      \item \verb|-s|: \emph{s}queeze. \verb!echo Maaan | tr -s a e! replaces each sequence of repeated \texttt{a}'s with a single occurrence of \texttt{e}, hence it gives \texttt{Men}.
    \end{itemize}
  \item \texttt{getopts}: built-in command of \texttt{bash} which allows to parse options and arguments passed to a script. Two quick and well-done tutorials can be found \href{https://www.computerhope.com/unix/bash/getopts.htm}{here} and \href{https://sookocheff.com/post/bash/parsing-bash-script-arguments-with-shopts/}{here}. We provide a hand-made example: \autoref{lst:getopt_ex}.
    \begin{itemize}
      \item Typically, one calls \verb|while getopts ":<option_list>" opt; do [...] done|. One may want to use a \verb|case| environment to deal with the options.
      \item Here above, \verb|option_list| contains the list of accepted options. If the option is followed by a \verb|:| (colon) it means that it requires arguments. The argument is stored in the macro \verb|$OPTARG|.
      \item \verb|\?| stands for an invalid/unknown option, \verb|:| (colon) for an option for which an argument is required but not provided.
    \end{itemize}
  \item Extract from path (considered as a string): \texttt{dirname} (root) and \texttt{basename}.
  \item Create QR-codes: \href{https://www.qrcode-monkey.com/}{here} is a pretty simple, 100\% free and highly customazible QR-code generator.
\end{itemize}

\begin{lstlisting}[language=bash,numbers=left,float,frame=single,caption={script.sh, an example for \texttt{getopts}},label={lst:getopt_ex},numberfirstline=true,stepnumber=5,firstnumber=1]
#!/bin/bash

usage () {
  echo "Usage: script.sh [ -p prefix ] [ -s suffix ]"
}

prfx=""
sffx=""

while getopts ":hp:s:" opt; do
  case "${opt}" in
    h )
      usage
      exit 0
      ;;
    p )
      prfx=${OPTARG}
      ;;
    s )
      sffx=${OPTARG}
      ;;
    : )
      echo "-${OPTARG}: An argument is required" 1>&2
      usage
      exit 1
      ;;
    \? )
      echo "-${OPTARG}: Unknown option" 1>&2
      usage
      exit 1
      ;;
  esac
done

echo "PFX = ${prfx}"
echo "SFX = ${sffx}"
\end{lstlisting}

\end{document}


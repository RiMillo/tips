%! TEX root = CS_tips.tex

%% Some random tips for bash and common commands. You'll find computer languages and git tips too.
%%
%% Copyright 2020 Riccardo Milani
%%
%% Licensed under the "THE BEER-WARE LICENSE" (Revision 42):
%% Riccardo Milani wrote this file. As long as you retain this notice you
%% can do whatever you want with this stuff. If we meet some day, and you think
%% this stuff is worth it, you can buy me a beer or coffee in return


\documentclass[a4paper,12pt,%
              final%
              %draft%
              ]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyvrb}

\usepackage{xcolor}
\definecolor{BlueX}{RGB}{0,62,92}

\usepackage[top=2cm, bottom=2cm, left=1cm, right=1cm]{geometry}

%\renewcommand{\ttdefault}{pcr}
\usepackage{listings}
\lstset{%
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
}

\usepackage{hyperref}

\usepackage{enumitem}
%
\begin{document}

% Title
\begin{center}
\bfseries \scshape \Huge \color{BlueX}%
Tips \& stuff
\end{center}
%
\vspace*{\baselineskip}

Some tips about terminal commands (\texttt{sed}, \texttt{grep}\ldots) and languages (\texttt{C}, \texttt{python}\ldots) are given here. For terminal commands, mind that you can access the related \emph{man}ual/help page by running
\begin{verbatim}
man <cmd>
\end{verbatim}
or sometimes
\begin{verbatim}
<cmd> --help
\end{verbatim}

\emph{Notations and conventions.} You will find stuff inside angle brackets (like this \verb|<.>|): this is something that you can choose. You will also find other stuff within square brackets (like this \verb|[.]|, and they can be nested): this indicates something that is optional.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shell}
\label{sec:shell}
There are different version of shells scripting, such as \texttt{bash}, \texttt{sh}, \texttt{zsh}; they have some differences in commands and syntax (but I do not know them \verb|\o/|). I will use \texttt{bash}.

\subsection{Shell (\texttt{bash}) basics}
In this section, we cover basic stuff about the shell. For useful terminal commands and tools, see the next sub-sections.
\begin{itemize}
  \item Of course I'm not the first to write tips, and certainly not the one who knows the most, so here a couples of tips lists, especially about shortcuts: \href{https://www.techrepublic.com/article/20-terminal-shortcuts-developers-need-to-know/}{here} and \href{https://www.howtogeek.com/howto/ubuntu/keyboard-shortcuts-for-bash-command-shell-for-ubuntu-debian-suse-redhat-linux-etc/}{here} and \href{https://devhints.io/bash}{here}.
    \begin{itemize}
      \item Cut \& yank: \texttt{<C-K>} cut (or \emph{k}ill) from cursor to end of line, \texttt{<C-U>} cut from cursor to beginning of line, \texttt{<C-W>} cut (blank-delimited) word just before the cursor, \texttt{<C-Y>} yank (paste).
      \item \texttt{<C-S-E>}: expand alias.
      \item \texttt{<C-R>}: search in the command history while typing.
      \item \texttt{<A-.>}: insert arguments of the previous (run) command;
      \item \texttt{<C-X-E>}: continue editing the bash command you are writing in the predefined editor.
      \item \texttt{!}: repeat stuff as explained \href{https://www.redhat.com/sysadmin/bash-bang-commands}{here}.
      \item Use braces (curly brackets) \verb|{ }| to save typing. Examples
        \begin{itemize}
          \item \verb|cp file_{orig,bkp}| expands to \verb|cp file_orig file_bkp|
          \item \verb|evince work{1,2,3}.pdf| expands to \verb|evince work1.pdf work2.pdf work3.pdf|
        \end{itemize}
    \end{itemize}
  \item Default applications: often we don't know the name of the programs that we use, for instance, for opening a pdf. Here some of them
    \begin{itemize}
      \item \texttt{evince} for pdf.
      \item \texttt{eog} for images.
      \item \texttt{nautilus} for file explorer.
    \end{itemize}
  \item Customize your terminal
    \begin{itemize}
      \item Pimp your \texttt{bash} by modifying the file \texttt{.bashrc} in your home (load modules that you want by default, set global variables,\ldots) and define personal shortcuts in \texttt{.bash\_aliases}, again in your home (verify that it is loaded in \texttt{.bashrc}).
      \item Preceding a terminal command with a backslash will tell the shell to run the command itself and not the alias with the same name if it exists.
      \item In \texttt{bash}, the keyboard combo \texttt{Ctrl+Alt+E} expands aliases and variables that you writing.
    \end{itemize}
  \item Run in background:
    \begin{itemize}
      \item Add a \verb|&| after a command to run it back ground, meaning that it won't block the terminal while running, so that you can still use the terminal window for other stuff. This is quite useful when opening GUI programs (e.g.~\texttt{evince}).
      \item Precede your commands with \texttt{nohup} in order to have them running ever after the terminal window / session is closed. More \href{https://linux.101hacks.com/unix/nohup-command/}{here} or \href{https://hexadix.com/use-nohup-execute-commands-background-keep-running-exit-shell-promt/}{here}.
    \end{itemize}
  \item Some built-in variables:
    \begin{itemize}
      \item \verb|$#|: number of arguments passed to the script
      \item \verb|$<n>|: argument \texttt{n}. It is 1-based, in fact \verb|$0| expands to shell / script's name
      \item \verb|$@|: all arguments. You can use it in a list: \verb|for arg in "${@}"|
      \item \verb|$!|: expands to the last run process's ID
      \item \verb|$?|: return value of last command. You can store it \verb|ret_val=$?| or use it directly
\begin{verbatim}
some_command
if [ $? -eq 0 ]; then
echo OK
else
echo FAIL
fi
\end{verbatim}
    \end{itemize}
  \item Operator \texttt{*} expands to all the files whose name does not start with "\texttt{.}". Hence, hidden files (as well as current directory "\texttt{.}", and parent directory "\texttt{..}" are not included).
  \item Arithmetic operations: \verb|$((4*n+3))|, notice that once inside the variables do not need the \$ sign. As it is the case for operator \verb|[| (cf. \autoref{ssec:shell_tools}), \verb|((| is a shortcut for a command, precisely \href{https://www.computerhope.com/unix/bash/let.htm}{\texttt{let}}. On shell such as \texttt{bash} only integers arithmetics are allowed. Many alternatives are available, for instance using \texttt{awk} (\autoref{ssec:awk}) or \texttt{python} (\autoref{sec:python}) or \texttt{bc} (\autoref{ssec:shell_tools}). Others may be found \href{https://unix.stackexchange.com/questions/40786/how-to-do-integer-float-calculations-in-bash-or-other-languages-frameworks}{here}.
  \item Conditional statements: \href{https://unix.stackexchange.com/questions/306111/what-is-the-difference-between-the-bash-operators-vs-vs-vs}{here}
  \item Pipes: \verb!|! connects standard output of one command to standard input of another.
  \item File descriptors:
    \begin{enumerate}[start=0,label={\texttt{\arabic*} :}]
      \item Standard input
      \item Standard output
      \item Standard error
    \end{enumerate}
  \item Use output of commands (for instance, to define a variable or a command)
    \begin{itemize}
      \item Brackets: \verb|$(cmd)|
      \item Backticks: \verb|`cmd`|
    \end{itemize}
  \item \href{https://www.gnu.org/software/bash/manual/bash.html#Redirections}{Redirection}: use \verb|>| to redirect, \verb|>&| to duplicate and redirect
    \begin{itemize}
      \item Redirect \texttt{stdout} to \texttt{stderr}: \verb|<cmd> 1>&2|
      \item Redirect \texttt{stdout} and \texttt{stderr} to file: first we redirect \texttt{stdout} to a file then we tell to copy \texttt{stderr} to \texttt{stdout}
\begin{verbatim}
  <cmd> > file.log 2>&1
\end{verbatim}
      \item Discard output: \texttt{<cmd> > /dev/null}.
      \item Pipe \texttt{stderr}. Aim: discard \texttt{stdout} and pipe \texttt{stderr}. \href{https://stackoverflow.com/questions/2342826/how-can-i-pipe-stderr-and-not-stdout}{Actions}: redirect \texttt{stderr} to \texttt{stdout}, discard \texttt{stdout}, pipe.
\begin{verbatim}
cmd 2>&1 >/dev/null | pipe_receiver
\end{verbatim}
      \item \verb|>| can be used to write to file: \verb|echo "Hello world!" > hello.txt| will write into the provided file. If the file already exists it will be replaced, otherwise it will be created. If you want to \emph{append} to the file just use \verb|>>|.
      \item You may want to check out \texttt{tee} in \ref{ssec:shell_tools}.
    \end{itemize}
  \item Input:
    \begin{itemize}
      \item \emph{Here}-strings: feed the content of a variable to a command with \verb|<<<|: \verb|grep [] <<< $var|
      \item \emph{Here}-documents: feed the content of a file created on-the-run to a command with  \verb|<<|:
\begin{verbatim}
grep [] <<EOF
First line
Second line
EOF
\end{verbatim}
        The keyword \texttt{EOF} is arbitrary (one can choose it freely) and delimits the beginning and the end of the document
    \end{itemize}
  \item Strings manipulation:
    \begin{itemize}
      \item A quick \href{https://sookocheff.com/post/bash/bash-string-operators/}{guide}, or the official \href{https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html}{manual}.
      \item Extract substring: \verb|${string:position:length}|. For more details have a look \href{https://stackoverflow.com/questions/1405611/how-to-extract-the-first-two-characters-of-a-string-in-shell-scripting}{here}.
      \item Remove pattern
        \begin{itemize}
          \item Starting match: shortest \verb|${variable#pattern}|; longest \verb|${variable##pattern}|
          \item Ending match: shortest \verb|${variable%pattern}|; longest \verb|${variable%%pattern}|
        \end{itemize}
      \item Replace pattern: first \verb|{$variable/pattern/replace}|; all \verb|{$variable//pattern/replace}|
      \item Operator \verb|=~|: \verb|${string} =~ ${regex}| gives true if \verb|string| matches the provided regex syntax.
    \end{itemize}
  \item In a script, adding at the beginning \verb|set -e| will make the script exit immediately as soon as one of its commands finishes with a non-zero status (when it fails).
  \item For option management \verb|getopts| is recommended, see \autoref{ssec:shell_tools}.
  \item Arrays: have a look \href{https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays}{here}. Access with \verb|${list[$i]}|
  \item Loops:
    \begin{itemize}
      \item For loops: have a look \href{https://www.cyberciti.biz/faq/bash-for-loop/}{here}. Quick examples:
\begin{verbatim}
for n in one two three; do [...] done
# {START..END} or {START..END..INCREMENT}
for n in {1..10}; do [...] done
for n in {1..10..2}; do [...] done
# 3-expression form (( INIT; COND; STEP )), C-like
for (( n=0; n<10; n++ )); do [...] done
\end{verbatim}
      \item While loops: \verb|while []; do [] done|
      \item Emulating do-while: see first two answers \href{https://stackoverflow.com/questions/16489809/emulating-a-do-while-loop-in-bash}{here}
      \item Combine loops and arrays: some examples
\begin{verbatim}
for n in (one two three); do [...] done
#
list=(one two three)
for n in ${list[@]}; do [...] done # Items only
for i in ${!list[@]}; do [...] done # Indeces only
\end{verbatim}
    \end{itemize}
  \item Notifications and dialogue windows: we really like the old-school terminal, but sometimes nice GUI stuffs and visual aides make life easier. Consider this: you launch a script which takes a really long time, so from the terminal you switch to do other stuff. It would be nice to be alerted when the said script finishes. I am still working on an audio signal, but consider these two options:
    \begin{itemize}
      \item \verb|notify-send "Title" "Body"|: a little notification pop-up
      \item More advanced: \verb|zenity|, Achieve notification, pop-up, interactive windows,\ldots Some stuff \href{https://renenyffenegger.ch/notes/Linux/shell/commands/zenity}{here}. Try \verb|zenity --<type> --text "Body"| where \texttt{type} can assume \texttt{notification}, \texttt{info}, \texttt{warning}, \texttt{error}, \texttt{text-info}, \texttt{progress}, \texttt{file-selection}, \texttt{list}, \texttt{entry}, \texttt{scale} and others. All but \texttt{notification} stop the flow of the script.
        \begin{itemize}
          \item Control the size with \verb|--width=<n>| and \verb|--height=<n>|
          \item \verb|--window-icon=/pat/to/icon|: choose an icon for your widget
          \item \verb|--timeout=<n>|: how long the widget should stay
        \end{itemize}
    \end{itemize}
  \item Quitting
    \begin{itemize}
      \item \verb|exit [error_number]|: quit the current section. That's exactly what you wish, if you are in a script or in a \texttt{ssh} connection. However, if you try it in a terminal or in a function, it will close the terminal.
      \item In order to quit a function without closing the terminal / script, use \verb|kill -INT $$|
    \end{itemize}
  \item Parallelize loops:
    \begin{itemize}
      \item Use background commands with \verb|&|: see \href{https://unix.stackexchange.com/questions/103920/parallelize-a-bash-for-loop/103922}{here}
\begin{verbatim}
for {...}; do
  do_something() &
done
\end{verbatim}
        Mind that this will spawn as many sub-processes as iterations in the loops, no matter the number of available cores
      \item As before, but limiting the number of processes: see \href{https://stackoverflow.com/questions/38774355/how-to-parallelize-for-loop-in-bash-limiting-number-of-processes}{here}
\begin{verbatim}
num_procs=$1
num_jobs="\j"  # The prompt escape for number of jobs currently running
for {...}; do
  while (( ${num_jobs@P} >= num_procs )); do
    wait -n
  done
  do_something() &
done
\end{verbatim}
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\texttt{sed}}
Bases:
\begin{itemize}
  \item Some info could be found in the \href{https://www.gnu.org/software/sed/manual/sed.html}{manual} or in \href{http://www.grymoire.com/Unix/Sed.html}{this tutorial}; \href{https://www.tutorialspoint.com/unix/unix-regular-expressions.htm}{this} could be useful as well.
  \item A general knowledge of the regex could be very useful. Take a look at this \href{https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285}{chetsheet}
    \begin{itemize}
      \item \verb|^pattern|: matches any string that starts with \texttt{pattern}. \verb|pattern$|: matches any string that ends with \texttt{pattern}
    \end{itemize}
  \item General usage: \verb|sed [options] "[range] <command>" old_file new_file|. Double quotes \texttt{"..."} may be replaced by single quotes \texttt{'...'}.
    \begin{itemize}
      \item If no \verb|new_file| is given, the result is printed to \texttt{stdout}.
    \end{itemize}
\end{itemize}

Commands:
\begin{itemize}
  \item Common commands may be found \href{https://www.gnu.org/software/sed/manual/sed.html#Common-Commands}{here}, less common ones \href{https://www.gnu.org/software/sed/manual/sed.html#Other-Commands}{here}, the \href{https://www.gnu.org/software/sed/manual/html_node/sed-commands-list.html}{list} from the manual
  \item Search and replace, \verb|s|:
\begin{verbatim}
  sed -i "s/<pattern>/<replaced>/" file
\end{verbatim}
  \item Replace all the lines matching \verb|pattern| with \verb|Pattern was here| - this works on the entire line, \verb|c <text>| or \verb|c\<newline><text>|:
\begin{verbatim}
sed -i "/pattern/c Pattern was here/" file,
\end{verbatim}
  \item Delete all lines containing \verb|pattern| - this works on the entire line:
\begin{verbatim}
sed -i "/pattern/d" file;
\end{verbatim}
  \item Insert before line, \verb|i <text>| or \verb|i\<newline><text>|
\begin{verbatim}
sed -i "/pattern/i Next line is pattern/" file,
\end{verbatim}
  \item Append after line, \verb|a <text>| or \verb|a\<newline><text>|
\begin{verbatim}
sed -i "/pattern/a Previous line was pattern/" file,
\end{verbatim}
  \item Apply multiple commands at the same time:
    \begin{itemize}
      \item Separate them with semicolons: \verb|sed 'cmd1 ; cmd2' file|
      \item Separate them with \verb|-e|: \verb|sed -e 'cmd1' -e 'cmd2' file|
      \item Group sever commands together with braces: \verb|{cmd1 ; cmd2}|
    \end{itemize}
\end{itemize}

Ranges: ranges are optional and it is the way to tell \verb|sed| to apply the provided commands only to those lines specified by the range. Some examples
\begin{itemize}
  \item \verb|4,10|: lines 4 to 10
  \item \verb|4,+6|: line 4 and the following 6 lines
  \item \verb|4,10!|: everything except lines 4 to 10
  \item \verb|4~3|: starting from line 4, every 3 lines
  \item \verb|/pattern/|: all the lines matching \verb|pattern|
\end{itemize}

Options and tricks:
\begin{itemize}
  \item The option \verb|-i[<suffix>]|, \verb|--in-place=[<suffix>]| allows to overwrite the file once it is modified. If \verb|suffix| is provided a backup is created with the chosen extension;
    \begin{itemize}
      \item \verb|-i.bak| creates a backup file,
      \item The option \verb|--follow-symlinks|, available only with \verb|-i| activated, enables to modify the original file;
    \end{itemize}
  \item If in one line there are more occurrences, only the first one is matched. Appending \texttt{g} will make \texttt{sed} match all the occurrences.
\begin{verbatim}
  sed -i "s/<pattern>/<replaced>/g" file
\end{verbatim}
  \item Character \verb|&| expands to matched string.
  \item Match exactly the word: from regex, \verb|\b| delimits boundaries of the word. Hence, (although \verb|\<word\>| seems to work, as well (\texttt{vim}, anyone?)):
\begin{verbatim}
$ echo "bar embarassment" | sed "s/\bbar\b/no bar/g"
no bar embarassment
\end{verbatim}
  \item Parentheses used in regex syntax (for groups \verb|(.)|, repetitions \verb|{.}|) should be escaped by a backslash: e.g. \verb|\(agroup\)|. Access groups content with \verb|\<n>| where \verb|n| is the number of the group. Or, add option \verb|-E|.
  \item Use \texttt{bash} variables: prefer the double-quotes \verb|"| instead of the single ones \verb|'|:
\begin{verbatim}
sed "s/${pattern}/${replaced}/" file
\end{verbatim}
  \item \verb|$| means last line when dealing with ranges, or end of the line when dealing with patterns.
  \item Mind that command \verb|d| erases the entire line, if you want to delete only the pattern, you can replace it with an empty string.
  \item Write at the beginning of the line: match the beginning (special character \verb|^|) and replace. For instance, in \texttt{C} comments all the lines containing \texttt{Comment} (mind that we have to escape character \verb|/|)
\begin{verbatim}
sed '/Comment/ s/^/\/\//' test.c
\end{verbatim}
  \item Replace only the first occurrence of \verb|pattern|: a bit tricky, find the right range (from line zero to first occurrence) then replace
\begin{verbatim}
sed '0,/pattern/ s/pattern/new pattern/' file
\end{verbatim}
  \item Replace only the last occurrence of pattern: I'm still working on that. A long and dirty workaround may be to use \verb|tac|, then replace \emph{first} occurrence and finally \verb|tac| again.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\texttt{grep}}
\label{ssec:grep}
\verb|grep [options] <pattern> [files]|

Some useful options:
\begin{itemize}
  \item \texttt{-r}: recursive, then \texttt{files} can be a directory;
  \item \texttt{-R}: as above, but follow links;
  \item \texttt{-w}: match only complete \emph{w}ords;
  \item \texttt{-c}: just print the \emph{c}ount of the lines with a match;
  \item \texttt{-v}, \verb|--invert-match|: get lines with that do \emph{not} match the \texttt{pattern};
  \item \texttt{-e}, \verb|--regexp=<pattern>|: look for \texttt{pattern}. This can be used, for example if \texttt{pattern} starts with a dash (\texttt{-}); similar options are \verb!-E|F|G|P!
  \item \texttt{-i}, \verb|--ignore-case|: search is case-\emph{i}nsensitive;
  \item \texttt{-h}: without filename (mnemonic: \emph{h}ead)
  \item \texttt{-H}: with filename (mnemonic: \emph{H}ead)
  \item \texttt{-n}: show line number;
  \item \texttt{-m <n>}: print only the first \texttt{n} occurrences of the \texttt{pattern};
  \item \texttt{-B <n>}: print \texttt{<n>} lines \emph{B}efore the match (included);
  \item \texttt{-A <n>}: print \texttt{<n>} lines \emph{A}fter the match (included);
  \item \texttt{-C <n>}: print \texttt{<n>} lines of the \emph{C}ontext of the match;
  \item \texttt{-l}, \verb|--files-with-matches|: \emph{l}ist only the file names in which at least one match is found;
  \item \texttt{-L}, \verb|--files-without-matches|: \emph{L}ist only the file names in which no match is found;
  \item \texttt{-q}: \emph{q}uiet, return just the exit status code (0 or 1 corresponding to, respectively, true or false) according to whether it have found a match or not;
  \item \verb|--include=<pattern>|: consider only files matching \texttt{pattern}. For example for only \TeX{} sources
\begin{verbatim}
grep --include=\*.tex -r "O Bella Ciao" .
\end{verbatim}
  \item \verb|--exclude=<pattern>|: do not consider files matching \texttt{pattern};
  \item \verb|--exclude-dir=<dir>|: exclude files in directory \texttt{dir};
\end{itemize}

Tricks:
\begin{itemize}
  \item Start from the end: \verb!tac <files> | grep [options] <pattern>! (Add a pipe to \texttt{tac} to recover the original order).
  \item Print even if the match is not found \verb!grep -E '^|<pattern>' <file>!. Special character \verb|^| means "beginning of the line", hence it is always found. Why should one use it? with the option \verb|--color| (usually enabled by default) \verb|grep| highlights the matches. Here, the command find the beginning of the line, which cannot be highlighted, hence it prints the line, if it finds the pattern as well it will highlight it.
\end{itemize}

Types:
\begin{itemize}
  \item \texttt{-G}, \verb|--basic-regexp|, simple regexp, default
  \item \texttt{-E}, \verb|--extended-regexp|
  \item \texttt{-P}, \verb|--perl-regexp|
  \item \texttt{-F}, \verb|--fixed-strings|, exclude regexp
\end{itemize}

The version \texttt{zgrep} (with the same options) allows to search into compressed/\emph{z}ipped files.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\texttt{find}}
It allows to find files in a tree and apply a command to them:
\begin{verbatim}
  find [options] <path> <command>
\end{verbatim}
If no command is given, \texttt{-print} is executed. Some examples and options:
\begin{itemize}
  \item Check if file \texttt{filename} is in \texttt{mydir} or one of its subdirectories (\texttt{-print} is considered, thus it works similarly to \texttt{ls})
\begin{verbatim}
  find <mydir> -name <filename>
\end{verbatim}
  \begin{itemize}
    \item In the previous examples, use \verb|-wholename| (instead of simply \verb|-name|) if you provide the path as well
    \item \verb|-regex|: similar to \texttt{name} but one can use regex syntax to write the pattern. The type can be chosen with \verb|-regextype| (ex. \texttt{sed}). Notice that \texttt{find} always prepends \verb|./| to the path so you may want to start your pattern with something like \verb|.*/|
    \item Case-insensitive search: use \verb|-iname| or \verb|-iregex| as you would use their parent options
  \end{itemize}
  \item Filter on the file type: option \verb|-type <t>| where \texttt{<t>} can be, for example, \texttt{d} (directory), \texttt{f} (regular file), \texttt{l} (symbolic link)\dots
  \item \texttt{!}, \texttt{-not}: negation of the expression that follows. E.g.: \texttt{find . -not -name foo} print all the files in the current directory with a name different than \texttt{foo}.
    \begin{itemize}
      \item Exclude a path:
\begin{verbatim}
find . -name notmyfile -not -path <dir_excl>
\end{verbatim}
        This is somehow too simple and \texttt{find} will still search into the sub-directories of \verb|dir_excl|. You may find other solutions \href{https://stackoverflow.com/questions/4210042/how-to-exclude-a-directory-in-find-command}{here} (the accepted answer with \verb|-prune|may not always work).
    \end{itemize}
  \item \verb|-maxdepth <n>|: limit the tree descent level of the search
  \item Apply a command to all the matching files: e.g.~run a bash script, grep only certain files
\begin{verbatim}
find . -name "*.log" -exec script.sh {} \;
find . -name "*.log" -exec script.sh {} +
find . -name "*.log" -exec grep -Hn --color "pattern" {} +
\end{verbatim}
    \verb|{}| stands for the matching files; the first version will execute as many calls as the numbers of matching files, the second (tries to) appends all the files in an single list of arguments (hence saving the calls to the script). If you would like to use a pipe in your \texttt{exec} command, use \texttt{sh} like below, or have a look \href{https://stackoverflow.com/questions/307015/how-do-i-include-a-pipe-in-my-linux-find-exec-command}{here}.
\begin{verbatim}
find . -name "*.log" -exec sh -c "tac {} | grep -m1 pattern" \;
\end{verbatim}
  \begin{itemize}
    \item Mind that \texttt{find} does not know the content of \texttt{.bashrc} and alike, hence one could not use aliases (its \texttt{ls} command might be stripped-down with respect to what one is used to, you may want to consider adding some user-friendly options).
  \end{itemize}
  \begin{itemize}
    \item \verb|-ok|: like \texttt{exec} but ask the permission first
    \item \verb|-execdir|: like \texttt{exec} but run the command from the subdirectory that contains the matched file.
  \end{itemize}
  \item Delete all the matching files: e.g.~delete all the \texttt{.log} files \texttt{find . -name *.log -delete}
    \begin{itemize}
      \item \texttt{-delete} calls \texttt{rm} under the hood, in fact it is practically equivalent to \texttt{-exec rm}. Hence it will fail if one tries to delete directory. In this case, use the long way: \verb|-exec rm -r {} \;|. You may add \verb|-prune| to avoid some warnings/errors. Moreover, one may add quote around braces to avoid errors with names that contains whitespaces.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Compressing: \texttt{tar} \& \texttt{zip}}
\texttt{tar} is a utility which creates archives
\begin{itemize}
  \item Basic usage:
    \begin{itemize}
      \item \verb|c|, \verb|-c|, \verb|--create|: create. Remember to put all the files that you want in your archive in one go.
\begin{verbatim}
tar -cf archived.tar file/to/archive
\end{verbatim}
      \item \verb|x|, \verb|-x|, \verb|--extract|, \verb|--get|: extract
\begin{verbatim}
tar -xf archived.tar
\end{verbatim}
      \item As you have already understood, \verb|-f| stands for file(name).
    \end{itemize}
  \item Additional options:
    \begin{itemize}
      \item \verb|t|, \verb|-t|, \verb|--list|: list the files.
      \item \verb|r|, \verb|-r|, \verb|--append|: add files to an existing archive.
      \item \verb|u|, \verb|-u|, \verb|--update|: add to the archive only the files which are already present and which have been modified.
      \item \verb|A|, \verb|-A|, \verb|--catenate|, \verb|--concatenate|: concatenate archives.
      \item Symbolic links: by default, \texttt{tar} keeps the links. If in the archive one wants a \emph{copy} of the \emph{original} file to which the link points to, option \verb!-h|--deeference! should be used.
      \item \verb|-C|, \verb|--directory <path>|: execute from \verb|path| (e.g.~decompress inside a given directory)
    \end{itemize}
  \item Compression algorithms:
    \begin{itemize}
      \item Zip (compress), \verb|-z|, \verb|--gzip|, \verb|--gunzip|, \verb|--ungzip|: use compression algorithms. The option has to be used also when extracting compressed archived. Usually, compressed archived have \verb|.tar.gz| or \verb|.tgz| as extension.
      \item \verb|-j|, \verb|--bzip2|
      \item \verb|-J|, \verb|xz|
    \end{itemize}
\end{itemize}

\medskip
A cross-platform extension for compressed files is \texttt{zip}. To compress simply run
\begin{verbatim}
zip [options] <compressed_file>.zip <files_to_compress>
\end{verbatim}
By default it adds links as hard-files (and not as links). Option \verb|-r| (mneno: \emph{r}ecursive) include also {sub}directories and their files.

To deflate, run \verb|unzip <compressed_file>.zip|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\texttt{awk}}
\label{ssec:awk}
\texttt{awk} is a text-processing utility that allows to perform easily operations line-by-line with column (here called \emph{fields}) manipulations. A tutorial is given \href{https://www.tutorialspoint.com/awk/index.htm}{here}.
\begin{itemize}
  \item Basis: \verb|awk [opt] 'BEGIN{[...]} {[...]} END{[...]}' <file>|
    \begin{itemize}
      \item The commands in the curly brackets after \texttt{BEGIN} are executed before starting the reading of the file,
      \item The commands in the unnamed curly brackets are executed at each line,
      \item The commands in the curly brackets after \texttt{END} are executed once the file has been read,
      \item Each of these three sections is optional;
    \end{itemize}
  \item A conditional statement (called \emph{pattern}) may be put just before the unnamed braces. Binary operations or comparisons can be used. If present, the commands inside are applied only to the rows verifying the pattern; if not, to all the rows. E.g.
    \begin{itemize}
      \item print the third row: \verb|awk 'NR==3{print;exit}' file.txt|
      \item print lines containing \texttt{apple}: \verb|awk 'BEGIN{print "We eat an"}/apple/' file.txt| (print is implied)
      \item More than one pattern might be used. No particular syntax is needed: nothing, a space or a newline will do the trick
\begin{verbatim}
awk '/apple/{print "Found an apple"}/banana/{print "Found a banana"}' infile
\end{verbatim}
    \end{itemize}
  \item Select the \texttt{n}-th field \verb|$<n>|. Remark: it is 1-based (first field is indexed by 1), and \verb|$0| expands to the whole line.
  \item Printing: it is usually achieved by command \texttt{print}. Some notes
    \begin{itemize}
      \item Columns are accessed with a dollar \verb|$|, for variables just use their name
\begin{verbatim}
awk '{print $NF}' file # Print last column only
awk -v T=8 'END{print "2 times T = " 2*T}' file
\end{verbatim}
      \item One can use redirection such as \verb|>|, \verb|>>| as explained in \autoref{sec:shell} to write to file. E.g.
\begin{verbatim}
awk 'BEGIN{print Ciao > "ciao.txt"}' file
\end{verbatim}
      \item \texttt{print} it also prints a new line stamp at the end
      \item \texttt{printf}, very similar to the \texttt{C} function, it can be used to choose the format. Differently from \texttt{print}, it does not insert a new line. E.g. (mind the \verb|\n|)
\begin{verbatim}
awk '{printf "I want %5.2f bananas\n" 1.652}' file
\end{verbatim}
    \end{itemize}
  \item Useful options:
    \begin{itemize}
      \item The file name is given as argument of the command or with \verb|-f <file>|, or \verb|--file=<file>|.
      \item \verb|-F <char>|, \verb|--field-separator="<char>"|: \verb|char| is the column separator (space is default);
      \item Pass an argument: \verb|-v var_name=<value>|
      \item When using \texttt{gawk} (the GNU implementation of \texttt{awk}) one can asks for in-place replacement: \verb|-i inplace|.
    \end{itemize}
  \item Built-in variables:
    \begin{itemize}
      \item \verb|NF|: number of fields / columns in the current row (hence \verb|$NF| is the last column of the row)
      \item \verb|NR|: row number, mind that it is incremented if several files are read (1 based).
      \item \verb|FNR|: row number relative to current file. It resets to 1 every time a new file is read.
      \item \verb|FS|: field separator
      \item \verb|FILENAME|: should I explain?
      \item \verb|ENVIRON|: array with environment variables (e.g.~try \verb|ENVIRON["USER"]|).
    \end{itemize}
  \item Tricks:
    \begin{itemize}
      \item \href{https://www.gnu.org/software/gawk/manual/html_node/String-Functions.html}{String-Manipulation functions}
      \item Operator "match", \verb|~| (tilde): \verb|<string>~<pattern>| true if \verb|string| matches \verb|pattern|. The negation is \verb|!~|. Hence, the following emulates \texttt{grep }(well, not exactly since we search in the second column only, but you get the idea)
\begin{verbatim}
awk '$2~/<pattern>/{print $0}' file.txt
\end{verbatim}
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Shell commands and tools}
\label{ssec:shell_tools}
\begin{itemize}
  \item \texttt{echo}: print a line to standard output. E.g. \verb|echo "Ciao World"|. It includes a newline at the end. It could be used via piping to provide an input parameter to a command.
    \begin{itemize}
      \item Variables can be used. Suppose you have \verb|what="cute puppy"|, then one can use
\begin{verbatim}
echo "I want a ${what}"
\end{verbatim}
      \item For redirection to files have a look at \autoref{sec:shell}.
      \item \verb|-n|: do not to insert a new line at the end.
      \item \verb|-e|: interpret a backslashed character, e.g. \verb|\n| will be considered as newline
      \item Overwrite: use \verb|\b| (needs option \verb|-e|) to go back a character. For entire lines, have a look \href{https://stackoverflow.com/questions/11283625/overwrite-last-line-on-terminal}{here}.
    \end{itemize}
  \item \href{https://man7.org/linux/man-pages/man1/script.1.html}{\texttt{script}}: save a shell session (commands and outputs) to a file
\begin{verbatim}
script session.log
[commands here]
exit
\end{verbatim}
    \begin{itemize}
      \item End the recording with \texttt{exit}
      \item \verb|-q|: quiet mode (do not print \texttt{script}-related ``greetings'')
      \item \verb|-a|: \emph{a}ppend to file
      \item \verb|-c <cmd>|: record command \verb|cmd| only (without starting an interactive session)
    \end{itemize}
  \item \verb|eval [args]|: \verb|args| are concatenated to build and run a command. Variables can be used:
\begin{verbatim}
cmd="ls"
echo "I will now $cmd in dir"
eval $cmd dir
\end{verbatim}
  \item Working with remote servers:
    \begin{itemize}
      \item \texttt{ssh}
        \begin{itemize}
          \item Connect to server: \verb|ssh [opt] [user@]server|. A new session open (a password may be requested). Use option \verb|-X| (or \verb|-Y|) to enable forwarding of the GUI, that is enabling GUI programs on the server
          \item Run command on a server: \verb|ssh [opt] [user@]server cmd| (or \verb|'cmd'|)
        \end{itemize}
      \item Transfer data, \texttt{rsync} or \texttt{scp}: \verb|rsync file.txt server:/home/user/path/to|. Notice the colon.
        \begin{itemize}
          \item \texttt{scp}: it's the inter-server equivalent of \texttt{cp}, it has basically the same options and usage
            \begin{itemize}
              \item In order to copy hidden files append a dot "\texttt{.}". E.g.:
\begin{verbatim}
scp -r [...] source/. user@server:dest/
\end{verbatim}
                If \texttt{source} is the current directory it is better to do (incompatibility introduced by 2019 standard): \verb|scp -r [...] $(pwd) user@server:dest/|. However, a good alternative for this kind of needs is \verb|rsync|
            \end{itemize}
          \item \texttt{rsync}: has a syntax similar to \texttt{mv} or \texttt{cp}. As the name suggests, it is a sort of synchronization tool, hence you can customize the effect so that only most recent and freshly edited files are moved. Indeed, it can be use entirely locally, for instance to update a copy / backup. If no destination is provided, \texttt{rsync} will behave similarly to \texttt{ls}.
            \begin{itemize}
              \item \verb|--copy-links|: copy as file \texttt{vs.} \verb|--links|: copy as link.
            \end{itemize}
          \item ATTENTION: \texttt{scp} and \texttt{rsync} load the \texttt{.bashrc} and fail if it produces an output to \texttt{stdout} (for instance, if they contain commands such as \texttt{echo}). The workaround is to move those commands into \texttt{.bash\_profile} (or just send the output to \verb|/dev/null| if it is not important)
        \end{itemize}
    \end{itemize}
  \item Download with command line: \texttt{wget} and \texttt{curl}
    \begin{itemize}
      \item Basic stuff \href{https://linuxconfig.org/download-file-from-url-on-linux-using-command-line}{here}
      \item With proxy \href{https://www.cyberciti.biz/faq/linux-unix-curl-command-with-proxy-username-password-http-options/}{here}; \verb|-x| option with \texttt{curl}; with \texttt{wget} you may want to export environmental variable \verb|http[s]_proxy|.
    \end{itemize}
  \item \verb|date [+"FMT"]|: get current date/time. Some of the instructions to build the format string follow:
    \begin{itemize}
      \item \verb|%H|, \verb|%M|, \verb|%S|: hours, minutes, seconds
      \item \verb|%T|, \verb|%r|, \verb|%R|: \verb|%H:%M:%S|, hour in 12-hours format, hour in 24-hours format
      \item \verb|%Y| (\verb|%y|), \verb|%m|, \verb|%W|, \verb|%d|: year (last two digits only), month, week, day
      \item \verb|%F|, \verb|%D|: equivalent to \verb|%Y-%m-%d| and \verb|%m/%d/%y| respectively
      \item \verb|%x|, \verb|%X|: respectively, date and hours according to region setting
    \end{itemize}
  \item Send email from terminal (because, why not. And yes, I have tried it in order to transfer a file from the cluster to my machine): look \href{https://www.tecmint.com/send-email-attachment-from-linux-commandline/}{here}, a quick \href{https://www.interserver.net/tips/kb/linux-mail-command-usage-examples/}{tutorial}.
\begin{verbatim}
  echo "Message Body Here" | \
      mailx -s "Subject Here" -a attachment.txt user@example.com
  echo "Message Body Here" | \
      mail -s "Subject Here" -A attachment.txt user@example.com
\end{verbatim}
  \item \texttt{wc}: \texttt{shell} command to perform some basic counting operations on a file (mnemonic: \emph{w}ord \emph{c}ount):
\begin{verbatim}
wc [options] <file>
\end{verbatim}
    \begin{itemize}
      \item \verb|-c|: print number of bytes;
      \item \verb|-w|: print number of words;
      \item \verb|-l|: print number of lines;
      \item \verb|-m|: print number of characters;
      \item \verb|-L|: print max line length;
      \item It usually (at least with \verb|-l|) re-prints the file name. To avoid use: \verb|wc -l < file.txt| (notice \verb|<|);
    \end{itemize}
  \item \texttt{sort [OPTIONS] [FILE]}
    \begin{itemize}
      \item if \texttt{FILE} is \texttt{-} or not given, it uses \texttt{stdin}
      \item \verb|-r|: \texttt{r}everse
      \item \verb|-u|: \texttt{u}nique
      \item \verb|-t <SEP>|: use \texttt{SEP} instead of blank space as field separator
      \item \verb|-f|: case insensitive
      \item \ldots and many others, check the man.
    \end{itemize}
  \item \texttt{uniq}: filter for repeated adjacent lines. Let me stress: only adjacent lines are checked
    \begin{itemize}
      \item \verb|-c|: prefix line with number of occurrences
      \item \verb|-d|: print repeated lines only occ
      \item \verb|-u|: print unique lines only
    \end{itemize}
  \item \texttt{test} or operator \verb|[| (square brackets): test if an expression is true. A quick \href{https://www.computerhope.com/unix/test.htm}{guide}. But the \texttt{man} page is clear and concise, just use this one. A little syntax:
    \begin{itemize}
      \item Conditional \verb|!| negate, \verb!-a|-o! and/or
      \item Strings: \verb!-z|-n! true if zero | nonzero, compare with \verb|=| and \verb|!=|
      \item Integers: \verb|-eq| equal, \verb|-ne| not-equal, \verb!-gt|-ge! (resp.~\verb!-lt|-le!) greater than | greater or equal (resp.~less)
      \item Files: \verb!-ot|-nt! older|newer than, \verb|-e| exists, \verb|-f| regular file, \verb|-d| directory
      \item Combine: \verb|[ a = a ] && [ b = b ]|, for or use \verb!||!. To construct multilevel conditions, one should escape parentheses
      \item ATTENTION: operator \verb|[[| (double square brackets) is a \texttt{bash} improvement of \texttt{test}, and allows more stuff (see this \href{https://stackoverflow.com/a/47576482}{comparison}), such as:
        \begin{itemize}
          \item \verb|$lhs =~ <regex>|: check if \verb|$lhs| match the given pattern
        \end{itemize}
    \end{itemize}
  \item \verb|touch <file>|: modify the file access and/or modification date. If the file doesn't exist, an empty one will be created (unless specific options are given). For more details and all the options, have a look at its \texttt{man} page.\\
  Why should one use it?
    \begin{itemize}
      \item Changing the modification date of a file will force a smart compiler such as \verb|make| to re-run the compilation.
    \end{itemize}
  \item \href{http://www.imagemagick.org/script/convert.php}{\texttt{convert}}: very powerful tool for manipulating images (part of the \href{https://imagemagick.org/index.php}{\texttt{image magick}} suite, some \href{http://www.imagemagick.org/script/command-line-processing.php}{tips})
    \begin{itemize}
      \item Convert: \verb|convert test.<ext1> test.<ext2>| the extension can be \texttt{pdf}, \texttt{jpg}, \texttt{png},\ldots
      \item Rotate: \verb|-rotate <deg>|
      \item Choose density|quality (and hence the final size): option \verb|-density <n>| (its unit is \texttt{dpi})
      \item Reduce size: \verb|-size <n>%| the output will have be the \verb|n|\% of the initial size
      \item Mirror image: \verb|-flip| vertical (meaning top becomes bottom) axis, \verb|-flop| horizontal axis (meaning right becomes left)
    \end{itemize}
  \item \href{https://github.com/DavidFirth/pdfjam#using}{\texttt{pdfjam}}: nice and easy utility to modify \texttt{pdf} files
    \begin{itemize}
      \item Extract and/or merge: Examples of accepted ranges: \texttt{'1,6-9'}, \texttt{'-2,4,6'}
\begin{verbatim}
pdfjam [options] -- file_1.pdf ['<page_range>'] \
                   [file_2.pdf ['<page_range>'] ...]
\end{verbatim}
      \item Rotate: Commands specified for certain angles are available: \verb!pdf90|180|270 <in.pdf>!
      \item A similar utility with a wider range of capabilities is \href{https://www.ghostscript.com/doc/current/Use.htm}{\texttt{ghostscript}}
      \item In fact, under the hood \texttt{pdfjam} calls \LaTeX{} and loads the pdf into a page. This is enough most of the time, however, if the pdf has non-standard dimensions, let say smaller than A4, this will result in a blank A4 page with the pdf at the center. To fit to the size, use \texttt{ghostscript} (for the pages, the option \texttt{-sPageList} is also available and accepts ranges)
    \end{itemize}
\begin{verbatim}
gs -dBATCH -dNOPAUSE -dSAFER -sDEVICE=pdfwrite -dPSFitPage \
   -dFirstPage=2 -dLastPage=5 -o out.pdf in.pdf
\end{verbatim}
  \item Job management:
    \begin{itemize}
      \item \verb|kill [options] <job_ID>|: kill (send \texttt{SIGTERM} to) the job denoted by \verb|<job_ID>|.
      \item \verb|pgrep [options] <pattern>|: print info, especially the job-IDs, of all the jobs matching \verb|<pattern>|. Option \verb|-l| lists the names as well (and not only the IDs).
      \item \verb|pkill [options] <pattern>|: as \verb|kill| but looks for matches in job names before (as \verb|pgrep|).
      \item Options for \verb!pgrep|pkill!
        \begin{itemize}
          \item \verb|-c|: count
          \item \verb!-l|-a!: lists names/fully
          \item \verb!-n|-o!: newest/oldest only
          \item \verb|-x|: select if name is exact
          \item \verb|-u UID|: only for user \verb|UID|
          \item \verb|-s SIG|: send signal \verb|SIG|
        \end{itemize}
    \end{itemize}
  \item \verb|[h]top|: \verb|top| (and its user-friendly version \verb|htop|) gives an overview of a running system. One can find, for instance and just to name the most useful features, which jobs are running and how much memory or processors are used.
    \begin{itemize}
      \item Filter: use option \verb|-p <ID>|. Using the job name instead of the ID is more convenient: have a look at \href{https://unix.stackexchange.com/a/347544}{this}: \verb|top -p `pgrep -d "," <name>`|.
    \end{itemize}
  \item \texttt{du}: shows the space used by the directories (and files) (mnemonic: \emph{d}isc \emph{u}sage)
    \begin{itemize}
      \item \verb!-a|--all!: show the space of every files, not only the directories
      \item \verb!-h|--human-readable!: use convenient units (MB,GB,\ldots)
      \item \verb!-d|--max-depth=<n>!: how many levels down the directory-tree \texttt{du} should search
      \item \verb|--exlude=<pattern>|: well, I think you get it
    \end{itemize}
  \item \texttt{df}: check disk space info about the system (mnemonic: \emph{d}isk \emph{f}ree / \emph{f}ilesystem)
  \item \texttt{time}: run programs and summarize system resource usage (from \texttt{man}). \verb|time my_script.sh|; get the execution time of the script. More insight \href{https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1/556411#556411}{here}.
  \item \texttt{uname}: print system info
  \item ``Safely remove'' disks from command line: use \texttt{udisksctl} as explained \href{https://askubuntu.com/questions/532586/what-is-the-command-line-equivalent-of-safely-remove-drive}{here}:
\begin{verbatim}
udisksctl unmount -b /dev/sdX
udisksctl power-off -b /dev/sdX
\end{verbatim}
  \item Con\emph{cat}enate files and print to standard output (basically print the content to screen)
    \begin{itemize}
      \item \verb|cat [<opt>] file [file2 [...]]|
      \item \verb|tac [<opt>] file [file2 [...]]| as above but reverse order of the lines
    \end{itemize}
  \item \verb|cp [options] <source> [dest]|: copy \texttt{source} into \texttt{dest} (if omitted, "\texttt{.}")
    \begin{itemize}
      \item \verb|-t|: target. \verb|cp -t dest -- <source>| is equivalent to \verb|cp <source> [dest]|
      \item \verb|-r|: recursive, useful for directories
      \item \verb|-u|: copy only if there is no file with the same name in \texttt{dest} or if \texttt{source} is newer (mnemonic: \emph{u}nique)
      \item \verb|-p|: preserve mode, ownership, and time-stamps
      \item \verb|-l|: (hard) link source instead of copy
      \item \verb|-L|: if \texttt{source} is a (symbolic) link, copy the file it points to instead of copying the link
    \end{itemize}
  \item \verb|crontab|: job scheduling. It allows one to regularly run some commands or scripts. Tutorial \href{https://www.adminschoice.com/crontab-quick-reference}{here} or \href{https://www.computerhope.com/unix/ucrontab.htm}{here}.
  \item \texttt{tee}: read from standard input and write to standard output \textbf{\&} files. Useful when you want to save the output of a command to file but you still want to read it on screen. E.g.
\begin{verbatim}
  echo "This'll be printed to screen and inside file.txt" | tee file.txt
\end{verbatim}
    \begin{itemize}
      \item \verb|-a|: append to file.
      \item Print to screen \& pipe: \verb!./script | tee /dev/tty | ./script_with_pipe!
    \end{itemize}
  \item \texttt{bc}: shell calculator (mnemonic: \texttt{b}asic \texttt{c}alculator)
    \begin{itemize}
      \item Some examples \href{https://www.geeksforgeeks.org/bc-command-linux-examples/}{here}.
      \item How to
        \begin{itemize}
          \item Simply run \texttt{bc} and an interactive interface will open (similar to what you get when you run \texttt{python}). Type \texttt{quit} for\ldots yeah, quitting.
          \item If you do not need extensive calculation but have just a one-liner expression, just pass it to \texttt{bc}: \verb!echo "20+5" | bc! or \verb|bc <<< "20+5"|
        \end{itemize}
      \item Operators like \verb|++|, \verb|*=|, etc.~are accepted
      \item Give option \verb|-l| to load the standard math library and, for instance, deal with floating point calculation and use standard functions (e.g.~sine \verb|s(x)|).
    \end{itemize}
  \item \texttt{tr}: \emph{tr}anslate, squeeze and/or delete characters from standard input. Basically performs string operations on standard input. Some options and examples
    \begin{itemize}
      \item \verb!echo Maaan | tr a e!: change \texttt{a}'s into \texttt{e}'s, hence the result is \texttt{Meeen}.
      \item \verb|-d|: \emph{d}elete. \verb!echo Maaan | tr -d a! gives \texttt{Mn}
      \item \verb|-s|: \emph{s}queeze. \verb!echo Maaan | tr -s a e! replaces each sequence of repeated \texttt{a}'s with a single occurrence of \texttt{e}, hence it gives \texttt{Men}.
    \end{itemize}
  \item \texttt{xargs}: use standard output to build commands (you can think of it as a more powerful way of piping). Have a look at some tutorials \href{https://shapeshed.com/unix-xargs/}{here} and \href{https://www.thegeekstuff.com/2013/12/xargs-examples/}{here}. Typical call is (the 0-related flags deal with files with spaces in their names)
\begin{verbatim}
find . -name foo -print0 | xargs -0 rm
\end{verbatim}
    \begin{itemize}
      \item \texttt{-t}: print the command
      \item \texttt{-p}: prompt a user-confirmation before executing the command
      \item \texttt{-n <n>}: group the inputs by \texttt{n}. That is, instead of (braces added for the sake of explanation) \verb|{1} {2} {3} {4}|, with \texttt{-n 2} one gets \verb|{1 2} {3 4}|.
      \item \texttt{-I}: enables \texttt{xargs} to execute multiple commands. In this case, \verb|%| is the placeholder for the input (sort of \verb|{}| in \verb|find -exec|)
      \item \texttt{-a <file>}: read from \texttt{file} instead of standard output
    \end{itemize}
  \item \texttt{cut}: cut out part of the content of the input. Typical call is:
\begin{verbatim}
cut -f 2-5 text.txt
\end{verbatim}
    print only columns (\texttt{f}ields) 2 to 5 of the content of file \verb|text.txt|.
    \begin{itemize}
      \item \verb|-f <list>| (or \verb|--fields|): print only fields in the list
      \item \verb|-b <list>| (or \verb|--bytes|): same as above but with bytes
      \item \verb|-c <list>| (or \verb|--characters|): same as above but with characters
      \item \verb|-d <,>|: use \verb|<,>| as delimiter for fields
      \item List examples: \texttt{n} or \texttt{n-m} or \texttt{-n} or \texttt{n-}
    \end{itemize}
  \item \texttt{getopts}: built-in command of \texttt{bash} which allows to parse options and arguments passed to a script. Two quick and well-done tutorials can be found \href{https://www.computerhope.com/unix/bash/getopts.htm}{here} and \href{https://sookocheff.com/post/bash/parsing-bash-script-arguments-with-shopts/}{here}. We provide a hand-made example in the appendix, \autoref{lst:getopt_ex}.
    \begin{itemize}
      \item Typically, one calls \verb|while getopts ":<option_list>" opt; do [...] done|. One may want to use a \verb|case| environment to deal with the options.
      \item Here above, \verb|option_list| contains the list of accepted options. If the option is followed by a \verb|:| (colon) it means that it requires arguments. The argument is stored in the macro \verb|$OPTARG|.
      \item \verb|\?| stands for an invalid/unknown option, \verb|:| (colon) for an option for which an argument is required but not provided.
    \end{itemize}
  \item Extract from path (considered as a string): \texttt{dirname} (root) and \texttt{basename}. E.g.: consider the following \texttt{path/to/file.txt}. Then \texttt{dirname} returns \texttt{path/to}, whereas \texttt{basename} \texttt{file.txt}.
  \item Convert from HEX to RGB colors from command line
\begin{verbatim}
hex="11001A"
printf "%d %d %d\n" 0x${hex:0:2} 0x${hex:2:2} 0x${hex:4:2}
\end{verbatim}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Debugging tools}
\subsection{\texttt{valgrind}}
Some useful options:
\begin{itemize}
  \item Check and track memory leaks: \verb|--leak-check=full| \verb|--track-origins=yes|
  \item Log file: \verb|--log-file=<filename>|
  \item Reachable / possibly-lost: \verb!--show-reachable=yes|no --show-possibly-lost=yes|no!
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\texttt{gdb}}
\label{sec:gdb}
\begin{itemize}
  \item Calling functions such as \texttt{fabs}, \texttt{sin},...: \texttt{((double(*)(double))<foo>)(x)}
  \item Setting watchpoints which stay after the end of the current function:
\begin{verbatim}
  $ print pt
    (double *) 0x75e12
  $ watch *(double *) 0x75e12
\end{verbatim}
  \item Print all current variables: \texttt{info args} (try also \texttt{info locals})
  \item Logging output \href{https://sourceware.org/gdb/onlinedocs/gdb/Logging-Output.html}{here}
    \begin{itemize}
      \item Enable/Disable logging: \verb!$ set logging on|off!
      \item Change name of the log file (default is \texttt{gdb.txt}): \verb|$ set logging file <name>|
      \item Overwrite: \verb!$ set logging overwrite on|off!
      \item Redirect only to file: \verb!$ set logging redirect on|off!
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{git}}
\label{sec:git}
A nice, user-friendly introduction to \texttt{git} is available \href{https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud}{here}. And the official documentation is \href{https://git-scm.com/doc}{here}.

Intro: for those who do not know, \texttt{SHA1} is either the ID (long or short, it does not matter) of the commit, which one can get via a \texttt{git log}, or a tree-path relative to the \texttt{HEAD} (e.g.: latest commit=\texttt{HEAD}, second to last=\verb|HEAD^| or \verb|HEAD~1|, ($n+1$)-th to last=\verb|HEAD~n|). More info \href{https://git-scm.com/docs/git-cherry-pick}{here}.

For inexperienced users who want to perform simple tasks, such as looking at the changelogs and commit history, or creating commits, the user-friendly, GUI programs such as \texttt{git-cola} (manage the current status of your git repository) and \texttt{gitk} (looking at the commit tree and moving around it) are advisable.

\emph{Bonus.} This could seem totally unrelated, but, here is one the most visited question on \texttt{StackOverflow} (more than 2 million times!) which deals with \href{https://stackoverflow.com/questions/11828270/how-do-i-exit-the-vim-editor}{How to exit the \texttt{Vim} editor}. You may want to have a look at this question which has more than 8 million views and it is indeed \texttt{git}-related: \href{https://stackoverflow.com/questions/927358/how-do-i-undo-the-most-recent-local-commits-in-git}{How do I undo the most recent local commits in \texttt{git}?}

\begin{itemize}
  \item Run \verb|git| commands from another directory: \verb|git -C <path> <cmd>| (mnemonic: as in \verb|make|). Originally it was: \verb|--git-dir=<path> --work-dir=<path>|.
  \item \verb|git add <file_name>|: move the modifications in \verb|file_name| to commit stage (that is, they will be include in the next commit)
    \begin{itemize}
      \item The option \texttt{-p}, aka cherry-picking, splits the \verb|file_name| into chucks, so that you can choose which modifications are to be staged. For each of them, you will have to tell \texttt{git} what to do with it: if it is to keep, answer \texttt{y}; if not, \texttt{n}. Other answers are possible, for example use \texttt{s} (for split) reduce the chunk size / split the current chunk into sub-chunks. \href{https://stackoverflow.com/questions/1122210/can-i-modify-git-adds-hunk-size}{Here} you can find the meaning of all of the possible answers. This could be done easily with \texttt{git-cola}.
    \end{itemize}
  \item \texttt{git commit}: creates a new commit with the staged modifications. This operation is easily done in \texttt{git-cola}.
    \begin{itemize}
      \item \verb|-m "Commit title"|: a simple and fast way to create a commit;
      \item \texttt{-a}: all the modified files, even those which are not staged yet are added to the commit;
      \item Forgot a file in your last commit or want to modify it? \verb|git commit --amend| add the staged modifications to the last commit.
      \item Commit with the same message as the original (after a reset, or with the \verb|--amend| option): \verb|git commit -c ORIG_HEAD|.
    \end{itemize}
  \item \href{https://www.conventionalcommits.org/en/v1.0.0/}{Conventional commits}: a style-guide for writing commits messages
  \item For all merging-related commands (\texttt{am}, \texttt{merge}, \texttt{cherry-pick}, \texttt{rebase}, \verb|pull --rebase|...), if errors occur, you can use
    \begin{itemize}
      \item \verb|git <command> --continue|: the problems have been solved, tells \texttt{git} to continue what it was doing,
      \item \verb|git <command> --abort|: cancel the operation and return to the pre-sequence state, the situation before \texttt{git <command>} was called,
      \item \verb|git <command> --quit|: similar to \texttt{abort}, but do not reset the \texttt{HEAD} back to the original branch. The index and working tree are also left unchanged,
      \item \verb|git <command> --skip|: in some commands, e.g.~the \texttt{rebase}-related ones, skip (do not apply) the current commit, and continue.
    \end{itemize}
  \item \verb|git reset [options] SHA1|, \href{https://git-scm.com/docs/git-reset}{here}:
    \begin{itemize}
      \item \verb|--soft|, Does not touch the index or the working tree at all, but resets the \texttt{HEAD} to \texttt{SHA1},
      \item \verb|--mixed|, (default) Resets the index but not the working tree (the files do not change),
      \item \verb|--hard|, Resets the index \emph{and} the working tree;
    \end{itemize}
  \item \verb|git rebase -i SHA1|: (\texttt{-i} stands for interactive) enables to modify (delete, move up or down the log tree, fix up, squash, reword) the commits from \texttt{SHA1} to \texttt{HEAD};
  \item Modify an old commit (for which \verb|--amend| would not work): use a \texttt{rebase -i}
    \begin{itemize}
      \item For basic modifications: look \href{https://stackoverflow.com/questions/1186535/how-to-modify-a-specified-commit}{here};
      \item For splitting a commit or complex modifications: follow \href{https://stackoverflow.com/questions/6217156/break-a-previous-commit-into-multiple-commits}{here} (I suggest to \texttt{rebase} to one commit before the one you want to modify).
    \end{itemize}
  \item (Re)set the remote reference (from where git pulls) for the branch \verb|branch_name|
\begin{verbatim}
  git branch [<branch_name>] --set-upstream-to new_remote/branch_on_remote
\end{verbatim}
    If \verb|branch_name| is not provided, the current branch will be used as default;
  \item Working with remote repositories
    \begin{itemize}
      \item Getting the latest commits: \verb|git pull|. One may want to add the \verb|--rebase| option so that your non yet published commits stay on top of the tree.
      \item Publish the latest local commits: \verb|git push|. It is always better to do a \verb|git pull --rebase| before pushing in order to avoid conflicts.
      \item Damn! You have just pushed a commit and you realize just now that it needs an amend. Modify it in you local repository then force-push it, have a look \href{https://stackoverflow.com/questions/179123/how-to-modify-existing-unpushed-commit-messages}{here}.
    \end{itemize}
  \item Rename a branch:
    \begin{itemize}
      \item If on the branch to rename: \verb|git branch -m <new_name>|
      \item If on another branch: \verb|git branch -m <old_name> <new_name>|
    \end{itemize}
  \item \href{https://git-scm.com/docs/git-format-patch}{Create patches} from \texttt{SHA1} to most recent commit: \verb|git format-patch [options] <SHA1>|
    \begin{itemize}
      \item \texttt{-<n>}: create only \texttt{n} patches (always starting from \texttt{SHA1});
      \item \verb|--start-number <n>|: the patches are numbered starting from \texttt{n};
      \item \texttt{-N}: commits are unnumbered.
    \end{itemize}
  \item \href{https://git-scm.com/docs/git-merge}{Merge} a branch: \verb|git merge [options] <to_merge>| incorporate all the commits of \verb|o_merge| onto the current branch. Some info also on \href{https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-request-merges}{\texttt{GitHub}}.
    \begin{itemize}
      \item If the history of the current and to-be-merged branch split, then an additional, automatically-generated commit is added (it is usually called ``Merge branch [\ldots]''). To avoid that, you can try to rebase \verb|branch_to_merge| over the final brunch, and possibly use the option \verb|--ff-only|.
      \item It \verb|branch_to_merge| has more than one commits, use \verb|--squash| to merge all its commits without, however, committing the changes into the current branch.
    \end{itemize}
  \item \href{https://git-scm.com/docs/git-am}{Apply a patch}: \verb|git am [options] path/to/patch|
    \begin{itemize}
      \item \texttt{-3}: if the patch does not apply cleanly for a certain file, falls back to the version of the most recent common commit between the current tree and the one coming with the patch, and propose a 3-way merge (current, patch, and ancestor),
      \item \verb|--reject|: when the application fails, tells \texttt{git} to apply as many modifications as possible and to temporarily skip the impossible ones. The rejected modification will be stored in \texttt{*.rej} files. The application has to be completed manually (you will have to personally modify the files)
    \end{itemize}
  \item \texttt{git log}: show the commit logs. \href{https://git-scm.com/docs/git-log}{Manual}
    \begin{itemize}
      \item \texttt{-<n>}, \texttt{-n <n>}: limit the number of commits to output
      \item \verb|--since=<date>|, \verb|--after=<date>|: show commits more recent than \texttt{date}
      \item \verb|--until=<date>|, \verb|--before=<date>|: show commits older than \texttt{date}
      \item \verb|-L <start>,<end>:<file>|: show commits which modified the zone of \texttt{file} delimited by the line numbers \texttt{start} and \texttt{end}
      \item \verb|-L:<function>:<file>|: show commits which modified function \texttt{function} of \texttt{file}
      \item \verb!--<path>|<path/to/filename>!: show commits which modified the files in \texttt{path} (resp.~the file \verb|path/to/filename|). To be put after all other options;
      \item \verb|--pretty[=<format>]|, \verb|--format=<format>|: customize the format of your output. You may want to choose predefined styles, then \texttt{format} can be chosen in \texttt{oneline}, \texttt{short}, \texttt{medium}, \texttt{full}, \texttt{fuller}, ...
    \end{itemize}
  \item Commit cherry-picking (\href{https://git-scm.com/docs/git-cherry-pick}{manual}): apply a specific commit from another branch
\begin{verbatim}
  git cherry-picking <commit>
\end{verbatim}
    \begin{itemize}
      \item Example: apply to the current branch the third-to-last commit of branch \verb|branch_name|:
        \begin{verbatim}
          git cherry-picking <branch_name>~4
        \end{verbatim}
    \end{itemize}
  \item Show config:
    \begin{itemize}
      \item Have a look at the global or local config file: \verb|~/.gitconfig| or \verb|repository/root/.git/config|
      \item List everything: \verb|git config [--global] --list|
      \item Specific key: \verb|git config [--global] --get <key_name>|
      \item Search: \verb|git config [--global] --get-regexp <pattern>|
    \end{itemize}
  \item Aliases: as for bash, one can create custom aliases to shortcut some common commands. In order to to that simply use
\begin{verbatim}
$ git config [options] alias.<shortcut> '<cmd>'
\end{verbatim}
        for instance
\begin{verbatim}
$ git config [--global] alias.pr 'pull ---rebase'
\end{verbatim}
  \item Proxy: some info are given \href{https://gist.github.com/evantoli/f8c23a37eb3558ab8765}{here}. Try to simply run (from wherever)
\begin{verbatim}
  $ git config --global http.proxy <server>:<port>
\end{verbatim}
  \item Ignore files from the syncing:
    \begin{itemize}
      \item Add them to \texttt{.gitignore}. Since \texttt{.gitignore} itself is synchronized, the exclusion is global and will stay in the tree, meaning that any new clone of the repository will see it; one can also add \texttt{.gitignore} to itself;
      \item Add them to \texttt{.git/info/exclude}. This is local and impacts only the local directory and clone of the repository.
    \end{itemize}
  \item \texttt{git} \textbf{cannot} track empty directories. Hence, one should include a dummy file and add it to the tree. Some people use \verb|.gitkeep| as naming convention for this dummy file.
  \item Push a new project to \href{https://github.com/}{GitHub} for the first time: follow \href{https://help.github.com/en/github/importing-your-projects-to-github/adding-an-existing-project-to-github-using-the-command-line}{this}.
  \item \texttt{git bisect}: help to find the commit causing the bug by a bisection procedure
    \begin{itemize}
      \item \verb|start|: initialize the procedure.
      \item \verb|bad [commit]|: tag commit as bad (default is current).
      \item \verb|good [commit]|: tag commit as good (default is current).
      \item \verb|reset|: once you have find the buggy commit, quit the procedure and go back to were you were at the beginning.
    \end{itemize}
  \item \verb|git grep| (\href{https://git-scm.com/docs/git-grep}{Manual}): it basically works as \verb|grep| (see \autoref{ssec:grep}) but on tracked files only: \verb|git grep 'time_t' -- '*.[ch]'|. Some bonus options:
    \begin{itemize}
      \item Notice that \verb|--| marks the end of the options.
      \item \verb|--and|, \verb|--or|, \verb|--not|. Option \verb|-e| should be used.
    \end{itemize}
  \item Submodules: \href{https://git-scm.com/book/en/v2/Git-Tools-Submodules}{here}.
  \item Sometimes the \texttt{.git} directory (where all the \texttt{git} magic happens) is larger than the projects itself: imaging having to store all the commits, changes,\ldots{} \href{https://stackoverflow.com/questions/5277467/how-can-i-clean-my-git-folder-cleaned-up-my-project-directory-but-git-is-sti}{Here} you find how to do a little house-keeping. \verb|git gc| might be an option, as well.
  \item \href{https://git-scm.com/docs/git-filter-branch}{\texttt{git filter-branch}}: modify the tree according to filters.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{C}}
\label{sec:c}
Just some tricks.
\begin{itemize}
  \item ATTENTION - Memory management. To some pointers and functions related to them such as \texttt{malloc}, \texttt{realloc} and \texttt{free}, are some of the most confusing things about \texttt{C}. Here, I do not pretend to explain everything, but let me tell you this, which should be a golden rule for developing in \texttt{C}: for every \texttt{malloc} that you call, remember to call also its related \texttt{free}. The impact of non-freed memory may be insignificant on certain problems, but it could quickly snowballing into something really dangerous and crash the run.
  \item It is advised by someone to use preprocessor false statements as a comment zone in which one can put anything (s)he wants to
\begin{verbatim}
#if 0
  This part won't be seen by the preprocessor
  Anything you want, no special caratchers needed
  Although some warning may be issued, for instance for unbalanced parantheses
#endif
\end{verbatim}
  \item Operator \verb|?| (ternary operator): it is a shortcut for a simple \texttt{if} statement.
\begin{verbatim}
  /* binary condition */ ? /* if true, do this */ : /* otherwise, do this */
\end{verbatim}
    For instance it could be useful when one wants to define a \texttt{const} variable which however depends on a certain condition.
\begin{verbatim}
  const int max = (n > m) ? n : m;
\end{verbatim}
    Notice that in this case, if \verb|m| or \verb|n| are calls to functions, they are evaluated twice, one for the comparison, and one for the assignment. Hence, if the calls are time-consuming, you might want to use temporary variables.
  \item \href{https://www.improgrammer.net/type-casting-c-language/}{Casting}: it is a way to change the type of a variable.
    \begin{itemize}
      \item Sometimes it is hidden: \verb|float a = 1;|. Because of its format, \verb|1| is actually interpreted as an integer and then cast into a floating-point number.
      \item Casting could be done explicitly:
\begin{verbatim}
old_type a = [...];
new_type b = (new_type)a;
\end{verbatim}
      \item The compiler will always try to cast, but if there is no correlation between the two data types unexpected behaviour and loss of precision may happen. Consider for instance
\begin{verbatim}
float a  = 1.1;
int   ab = (int) a;
\end{verbatim}
    \end{itemize}
  \item Memory / arrays tricks
    \begin{itemize}
      \item Fastest (?, possibly if one runs sequentially) to reset an array:
\begin{verbatim}
memset(dest, 0, dest_len*sizeof(<dest_type>))
\end{verbatim}
        (destination, value to copy, number of bits to consider). Notice that since it works on the single bits, this works only with zero, namely that would not work to fill an array with ones (or any value, indeed). Mnemonic: \verb|dest = 0|.
      \item Fastest (?, possibly if one runs sequentially) to copy an array into another: structure similar to the one above. Mnemonic: \verb|receive = send|
\begin{verbatim}
memcpy(receive, send, <n_element_to_copy>*sizeof(<send_type>))
\end{verbatim}
    \end{itemize}
  \item Booleans:
    \begin{itemize}
      \item Originally, \verb|0| means false and \verb|1| (well, actually, any integer different than zero) means true.
      \item Since \verb|C99|, the type \verb|_Bool| is introduced.
      \item The standard library \verb|stdbool.h| introduces \verb|bool| (which expands to \verb|_Bool|), \verb|false| (expands to \verb|0|) and \verb|true| (expands to \verb|1|).
    \end{itemize}
  \item Loops:
    \begin{itemize}
      \item \texttt{break} exits the innermost loop only (\texttt{for} or \texttt{while}). If one wants to exit all of them, a flag (a \verb|_Bool|/\verb|bool|) should be used.
      \item \texttt{continue} skips the rest of the current iteration, increases the counter and goes to the next iteration (stays in the loop!)
    \end{itemize}
  \item File reading/writing: \href{https://www.programiz.com/c-programming/c-file-input-output}{here}.
  \item Preprocessor
    \begin{itemize}
      \item Compile with \verb|-E| to get the source file preprocessed.
      \item \href{https://gcc.gnu.org/onlinedocs/gcc-7.5.0/cpp/Stringizing.html}{\emph{Stringizing}}
        \begin{itemize}
          \item Macro to make something a string, use \verb|#|: \verb|#define str(s) #s|
          \item Double it if you want to make the content of another macro a string
\begin{Verbatim}[samepage=true]
#define foo 4.0
#define str(s)  #s
#define xstr(s) str(s)
// Now use xstr(foo) -> "4.0"
\end{Verbatim}
        \end{itemize}
      \item Append / Concatenate: use operator \verb|##|. Consider this\footnote{Did you actually believe that \href{https://hitchhikers.fandom.com/wiki/42}{42} was not going to appear here?! You fool!}
\begin{Verbatim}[samepage=true]
float pow2(float x){return x*x;}
float pow3(float x){return x*x*x;}
#define _p(a,b) pow##b(a)
[...]
float var = 42.;
float var_square = _p(var,2); // Expands to pow2(var)
float var_cube   = _p(var,3); // Expands to pow3(var)
\end{Verbatim}
    \end{itemize}
  \end{itemize}
\subsection{Poorman optimizations}
  Here are some simple optimizations that you can consider, you can think of them as good practices. They won't certainly have much of an impact on the total runtime (in fact, especially with the loops, the compiler will try do anticipate what you want to do and optimize it), but it is useful to have them in mind and of course, it is definitely better to use them. A great deal of them deals with cache optimizations and avoiding cache-misses, it could be interesting to have a look at how a cache is and works and how to get the most out of it. Anywho, here are some optimizations:
    \begin{itemize}
      \item Constant variables. You need to define a variable and you know for sure from the beginning that its values will not change in the current scope. It is then advisable to define them as constant: the compiler will take into consideration this piece of information and use it to optimize the program. In order to make a variable constant, just prepend \texttt{const} to the usual definition \texttt{const int n = 10;}. You try to modify a value of a constant value, you'll get an error or at least a warning. You can also make the arguments of a function constant, this may be beneficial in three ways: optimization, allow the user to identify input and output parameter, and avoid error like modifying a value that you are not supposed to. However, it is usually not advised to make an argument of a function constant if it's one value (\texttt{int}, \texttt{float},\ldots) since in this case the performance gains will be null. Still it could be beneficial for the lecture.
      \item Data locality: try to define variables as close as possible to where you are going to use them. Basically, it is sometimes better to redefine a variable in a loop at each iteration rather than define it outside and change it at each iteration.
      \item Array accessibility. Somehow related to the previous point, you are looping through a huge array with hundreds or thousands of elements. If you are going to use the value several times, redefine a pointer that points just the current item. For instance,
\begin{verbatim}
for (int i=0; i < 10000; i++){
  double *a_i = a + i;
  // use now a_i[0]
}
\end{verbatim}
        This can be pretty useful if you are dealing with coordinates, for instance
\begin{verbatim}
for (int i=0; i < 10000; i++){
  double *a_i = a + 3*i;
  // a_i[0] will be the x-coordinate of the i-th point
  // a_i[1] the y one and a_i[2] the z one
}
\end{verbatim}
        Why that? Well, it actually takes some time to move in the memory to recover a value so accessing \texttt{v[1]} is (slightly) faster than \texttt{v[1000]}, having to doing it several thousands of times may impact the performances.
      \item Prefer arrays to matrices: using \verb|a[i][j]| is convenient but if the dimensions are large is pretty slow, the reason is somehow related to the previous item. Anyway, the bottom line is: A unique array is much faster: \verb|a[n_cols*i+j]| (if you have to choose only one optimization to remember, choose this one, big times)
      \item Prefer looping by columns rather than by rows. Another tips about memory and matrices, the reason of it is the cache: when the computer access a location in the memory, it also loads some chunks of memory that are just next to the one it actually needs, In this way, if it will need this additional piece of memory in the next iterations (as it is often the case), it already has it and avoid loading it thus saving some time. When looping by rows, the data that we request are (often) too far away from each other and a load at each iteration is almost certain. Bottom line: (notice the switch of the indexes and, most importantly, which loop is the innermost) this
\begin{verbatim}
for (int i=0; i < n_rows; i++)
  for (int j=0; j < n_cols; j++)
    a[i*n_cols+j] *= 2;
\end{verbatim}
        is better than
\begin{verbatim}
for (int j=0; j < n_cols; j++)
  for (int i=0; i < n_rows; i++)
    a[i*n_cols+j] *= 2;
\end{verbatim}
      \item Loop unrolling. Well, that is almost useless since the compiler will sometimes try do it even without being asked. However, a \texttt{for} loop has an overhead. So if it is not much of a fuss, you can try to write yourself by hand the iterations. Again, nowadays loop unrolling is practically useless but it is interesting to know how things work.
      \item Keep loops as straight as possible. The compiler will try to guess what the next operation will be, try to (almost) perform consecutive iterations at the same time, load some memory which is adjacent to the one you are requesting,\ldots{} you get the idea. If it does not manage, the program has to do unload what it thought and load what you really asked, and that takes time. Hence, avoid \texttt{if} statement in loops as much as possible, avoid jumping around an array, basically keep a straight path.
      \item Short types. Sometimes you know that a certain variables will not exceed a threshold, you can then using short types, which takes less memory than standard types. For instance, looping through the components of a vector, use \texttt{short int}
\begin{verbatim}
for (short int i=0; i < 3; i++){
  // Do something
}
\end{verbatim}
        (You may wonder, so why not use it all the times? Well, the maximum number that a short integer can represent is not that much and you may never reach the bound of the loop)
      \item Inline function. If a function is less than a dozen line long, consider inlining it. If this concept is new to you, know that: he code of an inline functions is copied as is where it is requested, so that by using inlined functions we don't get the overhead for the call to a function. Calling a long inlined function many times makes the executable larger (many lines of code) and that is something to avoid, hence, a dozen lines is a good thumb-rule.
      \item If dealing with synchronization in parallel mode, try to call those functions as less as possible. Instead of doing \texttt{n} times a synchronization of a vector of 3 values, prefer only one synchronization of a vector of \texttt{3*n} values.
    \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\texttt{OpenMP}}
\texttt{OpenMP} or \texttt{OMP} is a shared-memory interface for \texttt{C}/\texttt{C++} (and \texttt{Fortran} as well) for parallel computing. \emph{Shared-memory}, simply put, means that the memory may be accessed, read, and modified by any thread at any given moment. Most of the times, parallelize a piece of code with \texttt{OMP} comes down to prepend dedicated pragmas (\verb|#pragma omp [...]|) to \texttt{for} loops (the last two sentences were \emph{very} wrong, but it might get you on the right direction if this is the first time you have heard of parallelism and \texttt{OMP}). Now that you have the bigger picture and you are thinking "Well, that was easy, I can do it!", welcome to the hardest part, where not so rarely you have to change your piece of code in order not to have threads modifying each other's work.
  \begin{itemize}
    \item A nice training is available on the IDRIS \href{http://www.idris.fr/formations/openmp/}{website}.
    \item A \href{https://www.openmp.org/wp-content/uploads/OpenMP-4.0-C.pdf}{cheat-sheet} (for version 4.0).
    \item Unless dedicated instruction are provided (see a couple of items below), every line of code inside a parallel zone is executed by \emph{all} the threads.
    \item A killer feature is the \texttt{reduction}s: compute sums, find max/min, or any operation you'd like (as long as you define it).
    \item This is something that is true generally for any parallel framework not only \texttt{OMP}: parallel code and I/O operations (reading/writing) can become tricky pretty easily, be advised (Remember: several threads working on the same thing? Too many cooks spoil the broth).
    \item It is important to have in mind which commands are \emph{blocking}, meaning that have a hidden barrier at the end (a point at which all the threads have to meet before they are allowed to continuing the execution of the program). For instance, \verb|#pragma omp [parallel] for| is blocking (however, keep in mind the \verb|nowait| clause).
    \item Sometimes one need that one thread only may work on something at the same time. This is where \verb|#pragma omp critical| and \verb|#pragma omp atomic| come into play, where the last one provide better performances but allows only very few operations like reading, writing, and updating (e.g. \verb|sum += a[n];|).
    \item In parallel mode but this particular piece of code should be executed once and once only? Put it in dedicated pragmas like \verb|#pragma omp master| (only the master thread, usually the one with ID 0, is allowed to execute the code) or with \verb|#pragma omp single| (only the first threads arrived at that point executes it, this is your best choice most of the times). They have no barriers.
    \item Just to get it right, let us recap the difference between the last two points. With \texttt{critical} or \texttt{atomic} all the threads execute the command, but one at the time. With \texttt{single} or \texttt{master} the code is executed only once.
  \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{python}}
\label{sec:python}
(I used to be better with \texttt{python} but I don't use it so much now, so these tips here are not many nor much useful. I'm sorry. If you agree, please contribute!)
\begin{itemize}
  \item Debugging, info \href{https://docs.python.org/2/library/pdb.html}{here}: \texttt{python -m pdb script.py}. Commands are similar to \texttt{gdb} (\ref{sec:gdb}).
  \item Virtual environments: have look \href{https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/}{here} or \href{https://docs.python.org/3/tutorial/venv.html}{here}.
    \begin{enumerate}
      \item Create: \verb|python3 -m venv <env_name>|. The argument \verb|env_name| is arbitrary: let's fix it to \verb|test|
      \item Activate: \verb|source test/bin/activate|. From now on the python version of the virtual element is loaded, you may check this with \verb|which python|. Hence, for instance, \verb|pip| will install packages in the virtual environment only
      \item Deactivate: \verb|deactivate|
    \end{enumerate}
  \item \texttt{pip}: allows you to download and update python libraries
    \begin{itemize}
      \item Typical call: \verb|pip install <package>|. Add options \verb!--upgrade|-U! to upgrade.
      \item You'll need access to some directories, thus it is advised to have a local install: pass option \verb|--user|.
      \item Proxy: pass the option \verb|--proxy=user@server.dom:port|. However, it might not work if some dependencies have to be downloaded as well. In that case, try exporting the shell variables \verb|HTTP_PROXY=<proxy>| and \verb|HTTPS_PROXY=<proxy>|.
      \item Get list of outdated packages: \verb|pip list --outdated|.
      \item When installing/upgrading problems may occur with older versions of the \texttt{C} compiler, \texttt{GCC}: try and force \texttt{C99} standard by setting \texttt{CFLAGS} before installing: \verb|export CFLAGS='-std=c99'|
    \end{itemize}
  \item Format strings: several ways are available, have a look \href{https://realpython.com/python-string-formatting/}{here}
  \item \verb|pass|: does nothing. But it is useful as place holder
\begin{lstlisting}[language=python]
class This:
  pass # Remember to wrtite this
\end{lstlisting}
  \item \verb|try ... expect| and alike: An example
\begin{lstlisting}[language=python]
try:
    # Code here
except:
    # If error happens in try zone, this code is run...
else:
    # ... otherwise, if no exception caught, run this
finally:
    # This code is always run, with or without exception
\end{lstlisting}
  \item ``\verb|_|'': placeholder for unused parameter
  \item \href{https://wiki.python.org/moin/Generators}{Generators}: Generator functions allow you to declare a function that behaves like an iterator, i.e.~it can be used in a for loop. This is faster than creating lists on purpose. Brief \href{https://www.programiz.com/python-programming/generator}{intro}. Generators do not \emph{return}, they \emph{yield}. An example
\begin{lstlisting}[language=python]
def zero_or_square(n):
  for i in range(-n, n):
    if i <= 0:
      yield 0
    else:
      yield i**2

for i in zero_or_square(5):
  print(i)
\end{lstlisting}
  \item Data structures (the \href{https://docs.python.org/3/library/stdtypes.html}{manual} of all the predefined types) and how to create them
    \begin{itemize}
      \item Dictionaries: \verb|d = {'key':item}|
      \item Lists: \verb|l = [1, 2]|
      \item Tuples: \verb|t = (1, 2)|. ATTENTION: tuples are similar to lists, however they are immutable, for instance, you won't be able to do: \verb|t[0] = 2|
      \item Sets: \verb|s = {1, 2}|. Unordered, unique elements.
        \begin{itemize}
          \item Frozen sets: \verb|f = frozenset{[1, 2]}|. As sets, but immutable.
        \end{itemize}
    \end{itemize}
  \item Access arrays, lists:
    \begin{itemize}
      \item Operator square brackets, 0-based, separate dimensions with commas ``\texttt{,}''
      \item Negative indices means starting from the end, hence \texttt{a[-1]} is the last element
      \item \verb|a[start:end:range]|: \verb|a[i:j:n]| gives every \texttt{n}-th elements starting from \texttt{i} to \texttt{j}. If \texttt{i} (resp.~\texttt{j}) is omitted, defaults to first, \texttt{0}, (resp.~last, \texttt{-1}) element. E.g.: \verb|a[::2]| yields every other element.
      \item \verb|a[start:end]|: \verb|a[i:j]|: elements from \texttt{i} to \texttt{j}. If \texttt{i} (resp.~\texttt{j}) is omitted, defaults to first, \texttt{0}, (resp.~last, \texttt{-1}) element
      \item E.g.: \verb|l[::-1| reverse the list
      \item ``\verb|:|'': everything. \verb|a[:,n]|: the \texttt{n}-th column
    \end{itemize}
  \item Lists, let \verb|l| be a list of natural integers for the sake of simplicity (notation: \verb|i| stands for index, \verb|n| for natural integer)
    \begin{itemize}
      \item Insertion, elimination: \verb|l.append(n)| (in-place, it returns \verb|None|), \verb|l.insert(i,n)| \verb|l.remove(n)|, \verb|l.pop(i)| (remove \texttt{i}-th element, default 0)
      \item It accepts \verb|l.max()|
      \item Loop both on indices and values: \verb|for i, v in enumerate(l):|
      \item Initialize (list comprehension): \verb|l = [0 for _ in range(3)]|
      \item Search for: \verb|l.index(n)|
      \item Reverse: \verb|l.reverse()| in-place, \verb|l[::-1]|
      \item Sorting: \verb|l.sort()| in-place, \verb|sorted(l)| returns a new list
      \item List comprehension: \href{https://www.programiz.com/python-programming/list-comprehension}{here}.
    \end{itemize}
  \item Dictionaries: have a look \href{https://realpython.com/python-dicts/}{here}
    \begin{itemize}
      \item In recent versions, they are ordered
      \item Create: empty \verb|d = {}| or \verb|d = dict()|; not empty \verb|d={key:value}| or \verb|dict()| plus list of tuples. \verb|key| and \verb|value| can be of any (?) type.
      \item Add new item or update existing: \verb|d[key]=value|, \verb|d.update| accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two)
      \item Access: by key \verb|d[k]=val|; by index \verb|d[2]=val|; \verb|d.get(<key>[, <default>])| returns the value if \texttt{k} is a key (otherwise, \texttt{default})
      \item \verb|d.items()|: returns a list of key-value pairs
      \item \verb|d.keys()|: returns a list of keys
      \item \verb|d.values()|: returns a list of values
      \item \verb|d.pop(k,[default])|: If \texttt{k} is in the dictionary, removes it and return its value, else return \texttt{default}
      \item \verb|d.clear()|: remove everything
    \end{itemize}
  \item Sets: Operation and stuff (see \href{https://realpython.com/python-sets/}{here})
    \begin{itemize}
      \item Union (any element): \verb!s1 | s2! or better \verb|s1.union(s2)|
      \item Intersection (elements in both): \verb|s1 & s2| or \verb|s1.intersection(s2)|
      \item Difference (elements in \verb|s1| only): \verb|s1 - s2| or \verb|s1.difference(s2)|
      \item Symmetric difference (not in intersection): \verb|s1 ^ s2| or \verb|s1.symmetric_difference(s2)|
      \item And many others: \verb|s1.isdisjoint(s2)|, \verb|s1.issubset(s2)| or \verb|s1 <= s2| or \verb|s1 < s2| for proper subset\ldots
    \end{itemize}
  \item Ternary operator:
\begin{lstlisting}[language=python]
msg = "True" if condition else "False"
\end{lstlisting}
    or suppose that you have an argument which can be passed or not (hence in this case equal to \verb|None|)
\begin{lstlisting}[language=python]
msg = arg_msg or "Your message here"
\end{lstlisting}
  \item Classes: random stuff about classes (hidden) methods
    \begin{itemize}
      \item \verb|__init__(self[,args])|: creator
      \item \verb|__call__(self[,args])|: overload operator \verb|( )|
      \item \verb|__getitem__(self, key)|: overload evaluation with operator \verb|[ ]|, e.g.~\verb|a = obj[n]|
      \item \verb|__setitem__(self, key)|: overload assignment with operator \verb|[ ]|, e.g.~\verb|obj[n] = a|
      \item \verb|__add__(self, other)|: overload operator \verb|+|, see \href{https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types}{here}.
        \begin{itemize}
          \item You may overload also \verb|-| with \verb|__sub__|, \texttt{*} with \verb|__mult__|, etc\ldots
          \item \verb|a + b| is interpreted as \verb|a.__add__(b)|. However, lets say that \texttt{a} is not an instance of your class, but \verb|b| is. In this case, only be \verb|b + a| work. In order to take into account also the Reverse case, define also \verb|__radd__| (\verb|__rsub__|,\ldots). Most of the time, if the operation is symmetric, one can simply put \verb|__radd__ = __add__|.
          \item The in-place versions of the above mentioned operators are: \verb|__iadd__| for \verb|+=|, \verb|__isub__| for \verb|-=|,\ldots
        \end{itemize}
      \item \verb|__int__(self)|: overload cast \verb|int(<n>)|. Same applies for \verb|str|, \verb|float|
      \item \verb|__eq__(self,other)|: overload \verb|==|. Similarly, \verb!__ne|lt|le|gt|ge__!
        \begin{itemize}
          \item If \texttt{eq} not present, \texttt{==} is ensured by \texttt{is} (checks the ID)
          \item As long as there is a \texttt{==}, you can use the \verb|[not] in| keyword
        \end{itemize}
    \end{itemize}
  \item \texttt{numpy} and the \texttt{axis} keyword
    \begin{itemize}
      \item TL;DR: \verb|axis=0| acts by column, \verb|axis=1| by row. Hence,
\begin{lstlisting}[language=python]
x=numpy.ones([3,4])
x.sum(axis=0) # Gives [3, 3, 3, 3]
x.sum(axis=1) # Gives [4, 4, 4]
\end{lstlisting}
      \item The value of \texttt{axis} indicate on which dimension the operation is done (in a certain sens, which direction collapses after the operation).
      \item The value correspond to the index of the direction in, for instance, the result of \verb|numpy.size()|. Think about it: above \verb|x| was a 3-rows-4-columns matrix. Then, \verb|x.size() # =(3,4)|
    \end{itemize}
  \item \href{https://docs.python.org/3/library/tkinter.html}{\texttt{tkinter}}: manage windows and dialogue
  \item \texttt{args} and \texttt{kwargs}: have a look \href{https://realpython.com/python-kwargs-and-args/}{here}
  \item Parallelization: Couple of resources:
    \begin{itemize}
      \item \href{https://docs.python.org/3/library/multiprocessing.html}{\texttt{multiprocessing}} module.
      \item \href{https://docs.python.org/3/library/threading.html}{\texttt{threading}} module.
      \item An \href{https://www.machinelearningplus.com/python/parallel-processing-python/}{intro} with simple examples.
    \end{itemize}
  \item \texttt{matplotlib}
    \begin{itemize}
      \item \texttt{matplotlib.ion()} switch the interaction with the plot on, so that \texttt{plt.plot()} is not blocking and the plot can be kept and redrawn multiple times. This of course works in a plot environment, if you use it on a script the plot will disappear as soon as the script reaches its end.
      \item 3D plots. A nice introduction can be found \href{https://jakevdp.github.io/PythonDataScienceHandbook/04.12-three-dimensional-plotting.html}{here}. To activate 3D-plotting (scatter, surface, mesh plot or any other) the axis should be called with \lstinline[language=python]{projection='3d'} which should be imported as follows: \lstinline[language=python]{from mpl_toolkits import mplot3d}
    \end{itemize}
  \item Argument parsing: \href{https://docs.python.org/3/library/argparse.html#module-argparse}{\texttt{argparse}}
  \item Progress bar: \href{https://github.com/tqdm/tqdm#manual}{\texttt{tqdm}}
  \item \href{https://mypy.readthedocs.io/en/stable/index.html}{\texttt{mypy}}: write annotations indicating the types of your variables, parameters, and return values, then run \texttt{mypy} to check if your code is coherent (are you assigning a list to a variable that should a dictionary? and so on\ldots). The annotations do not interfere with the code when you are running directly the script.
  \item Statistics and data analysis:
    \begin{itemize}
      \item \texttt{scipy.stats}: hypothesis testing and all the basics.
      \item \texttt{statsmodels}: regressions.
      \item \href{https://seaborn.pydata.org/introduction.html}{\texttt{seaborn}}: powerful data visualization tool.
    \end{itemize}
\end{itemize}

\subsection{Writing documentation}
We give here some tips about writing documentation for your \texttt{python} code using \href{https://www.sphinx-doc.org/en/master/index.html}{\texttt{sphinx}}, basic ideas are \href{https://docs.python-guide.org/writing/documentation/}{here}. The main features of \texttt{sphinx} are that it provides building procedures, it is highly customizable, it uses reStructured Text (a markup language similar to \texttt{markdown}, \autoref{sec:markdown}) and can automatically process the docstrings.

First of all, here some info about docstrings, defined \href{https://www.python.org/dev/peps/pep-0257/}{here}. They are the comment-like lines just after function / class declarations, included in triple single- or double-quotes (\verb|'''| or \verb|"""|), that are read by python when invoking \texttt{help( )} or \texttt{doc( )}, \href{https://www.geeksforgeeks.org/python-docstrings/}{here} is basic stuff, also \href{https://www.programiz.com/python-programming/docstrings}{here}.

There are docstrings conventions that can be read and processed by \texttt{sphinx} so that it can generate automatically the documentation. The two most well-known and used are \href{https://www.programiz.com/python-programming/docstrings}{Google style} (example \href{https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html}{here}), and the \href{https://numpydoc.readthedocs.io/en/latest/format.html}{NumPy style} (example \href{https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html#example-numpy}{here}, mind that this format needs an additional extension of \texttt{sphinx}, we'll come back on this later). In short, choose one of the styles, used it coherently, so that you may create your doc in no times. In order for the docstrings to be understood by \texttt{sphinx}, you may use \texttt{sphinx} directive, like \href{https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html#an-example-class-with-docstrings}{this}, but the docstrings are a little less readable.

Now comes the real part about using \texttt{sphinx}. I am no wiz, I just figured out a couple of tricks by trial'n'error. Before getting into the detail myself, let me just give some web posts which (somehow) details the procedure: \href{https://betterprogramming.pub/auto-documenting-a-python-project-using-sphinx-8878f9ddc6e9}{here}, \href{https://samnicholls.net/2016/06/15/how-to-sphinx-readthedocs/}{here}, \href{https://eikonomega.medium.com/getting-started-with-sphinx-autodoc-part-1-2cebbbca5365}{here} (keep this for \texttt{automodule} / \texttt{autodoc}), \href{https://medium.com/@richdayandnight/a-simple-tutorial-on-how-to-document-your-python-project-using-sphinx-and-rinohtype-177c22a15b5b}{here}.
\begin{enumerate}
  \item Install \texttt{sphinx} if you don't have it with \texttt{pip install Sphinx}. It is advised to use virtual environments.
  \item \texttt{sphinx} uses a configuration file \texttt{conf.py}. The default configuration may be set up by running \texttt{sphinx-quickstart} and answering its question. You may want to activate the \texttt{autodoc} (automatically generates from docstrings), \texttt{intersphinx} (generates links within documentations), \texttt{coverage} (checks if you forgot to document something), \texttt{viewcode} (provides links to the code), and possibly even \texttt{doctest} (runs some examples found in the docstrings) extensions. The \texttt{Makefile} is quite useful, too. Now, you have set your doc up.
  \item You should say to \texttt{sphinx} where your scripts are. Open \texttt{conf.py} and uncomment the first imports (\texttt{os} and \texttt{sys}) and the path insertion: default is current directory, adjust with the path which is right for you.
  \item In the \texttt{conf.py}, you may also change a number of settings and extensions:
    \begin{itemize}
      \item Theme: default is ``alabaster''. See \href{https://sphinx-themes.org/}{here} for a gallery. Among the most used ones, is the ReadTheDocs theme: \verb|sphinx_rtd_theme|
      \item Extensions: the above mentioned \texttt{autodoc}, \texttt{intersphix},\ldots are already loaded if you asked for them in the quickstart. If using the NumPy style, you should activate also the Napoleon extension, hence add \texttt{sphinx.ext.napoleon} to the list.
      \item And a lot of more stuff
    \end{itemize}
  \item If you want \texttt{sphinx} to automatically generate the doc from your docstrings, you should tell it in the \texttt{index.rst} file as explained in item 8 \href{https://medium.com/@richdayandnight/a-simple-tutorial-on-how-to-document-your-python-project-using-sphinx-and-rinohtype-177c22a15b5b}{here} or \href{https://eikonomega.medium.com/getting-started-with-sphinx-autodoc-part-1-2cebbbca5365}{here}.
    \begin{itemize}
      \item This enables \texttt{sphinx} to do it all by itself, otherwise, you can also do it yourself using the utility \texttt{sphinx-apidoc} as mentioned \href{https://samnicholls.net/2016/06/15/how-to-sphinx-readthedocs/}{here}.
    \end{itemize}
  \item Now, if you asked for the \texttt{Makefile}, you just need to run \verb|make html| (or \texttt{latexpdf}, or anything that pleases you) and your doc is generated in the \verb|[]_build| directory.
  \item That's it.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{markdown}}
\label{sec:markdown}
\begin{itemize}
  \item \texttt{markdown} files are usually used for \texttt{README} and such.
  \item Common extension: \texttt{.md}, \texttt{.markdown}
  \item Compile them with \texttt{pandoc} in order to get an \texttt{html}, for instance, that you can open with a browser.
\begin{verbatim}
pandoc --from=markdown --to=html -o out.html in.md
\end{verbatim}
  \item Guides, cheat-sheet and tutorial:
    \href{https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet}{\texttt{Git-Hub}-flavoured},
    \href{https://daringfireball.net/projects/markdown/syntax}{official}, quick
    \href{https://commonmark.org/help/}{cheat-sheet} and a
    \href{https://agea.github.io/tutorial.md/}{tutorial} and
    \href{https://enterprise.github.com/downloads/en/markdown-cheatsheet.pdf}{cheat sheet again}.
  \item Official \texttt{GitHub} \href{https://docs.github.com/en/github/writing-on-github/basic-writing-and-formatting-syntax}{documentation}.
  \item Citations, references, bibliography: \href{https://stackoverflow.com/questions/26587527/cite-a-paper-using-github-markdown-syntax}{here}.
  \item \texttt{grip}: \texttt{python}-based script which allows you to have a \texttt{GitHub} rendering of your documents (needs internet to send request for translation to \texttt{GitHub}).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{gnuplot}}
\begin{itemize}
  \item Keep the plot-windows open after closing the platform / having run the script: \verb|gnuplot --persist|
  \item Scripts: A script is just a sequence of \texttt{gnuplot} commands.
    \begin{itemize}
      \item There is no official extension, although the most common are: \texttt{gpi} (recognized by \texttt{vim}), \texttt{plt}, \texttt{gp}, \texttt{gnu}.
      \item To launch: \verb|gnuplot script.gpi| from terminal, or \verb|load 'script.gpi'| inside a \verb|gnuplot| session
    \end{itemize}
  \item Variables: simply \verb|var = 8.5|, or \verb|var = 'smth'|
  \item New figure: \verb|set term xterm <n>| where \verb|n| is the ID
  \item Basic plotting from file: e.g.~use column 1 as x and 2 as y (mind \texttt{u} is equivalent to \texttt{using})
\begin{verbatim}
plot "file.dat" using 1:2 [options]
\end{verbatim}
  \item Multiple plots in the same picture. Usually, when executing \texttt{plot}, the old picture is cleared. To plot several curves separate them with a comma or use \verb|replot|. Indeed, the following
\begin{verbatim}
plot "file.dat" u 1:2 [options], "file2.dat" u 1:3 [options]
\end{verbatim}
    is equivalent to
\begin{verbatim}
plot "file.dat" u 1:2 [options]
replot "file2.dat" u 1:3 [options]
\end{verbatim}
  \item Subplots: \verb|set multiplot <n_rows>,<n_cols>| dispose the following plots in \verb|n_rows|$\times$\verb|n_cols| structure. Each \verb|plot|-like command will automatically switch to the following slot in the structure.
  \item Save:
    \begin{enumerate}
      \item Change terminal to the chosen output: \verb|set term postscript|, for \texttt{.ps} files. Use \texttt{png} for \texttt{.png} files instead. In this latter case, you can choose the size in pixels: \verb|set term png size 600,400|
      \item Choose name (according to the output): \verb|set output "plot.ps"|
      \item Plot into file: \verb|replot|
      \item Go back to initial terminal: \verb|set term x11|
    \end{enumerate}
  \item Column separator: for instance, with a \texttt{.csv} file one would use \verb|set datafile separator ','|
  \item Column names/headers: if columns has names/headers, you can use them instead of indices, using \verb|(column('name'))|. Yes, the brackets are necessary
\begin{verbatim}
plot file u (column('time')):(column('price'))
\end{verbatim}
  \item If a plot is already shown, and you run a \verb|set <cmd>| command, this will be active starting from the next \verb|plot|-like command only. Hence, you may want to run a \verb|replot| to update the figure with the new setting.
  \item Log scale: \verb!set log x|y!
  \item Plot title: \verb|set title 'Plot title'|
  \item Axis labels: \verb!set x|ylabel 'Label'!
  \item Legend:
    \begin{itemize}
      \item Deactivate: \verb|unset key| or \verb|set nokey|
      \item Place: \verb|set key <pos>| where \verb|pos| may assume: \verb|left top|,\ldots, \verb|outside|
      \item If columns have names and you want to use as legend labels: \texttt{set key autotitle columnhead}
    \end{itemize}
  \item Axis limits: \verb!set x|yrange [<min>:<max>]! or simply put \verb![<xmin>:<xmax>] [<ymin>:<ymax>]! after plot
  \item Color cycles: \verb!set colorsequence default|classic|podo!
  \item Loops: have a look \href{https://stackoverflow.com/a/18592561}{here} and \href{https://stackoverflow.com/a/14947085}{here}. From the first link (\verb|word| extract a word from a string)
\begin{verbatim}
colors = "red green #0000FF"
files = "file1 file2 file3"
plot for [i=1:words(files)] word(files, i).'.dat' lc rgb word(colors, i)
\end{verbatim}
\end{itemize}
Useful options of \texttt{plot}-like commands:
\begin{itemize}
  \item \verb!linecolor|lc!: e.g. \verb|lc "black"|. For more advance setting: \verb|linetype rgb "<parameters>"|
  \item \verb!with|w!: lines and marks \verb|linespoints|, lines/marks only \verb!lines|points!, \verb|impulses|
  \item \verb|pointtype <n>| (or \verb|pt|): set style \texttt{n} for the point. There are also \verb|pointsize| (or \verb|ps|)
  \item \verb|title "<legend_entry>"|. If columns have names, \verb|title columnhead|
  \item \verb!linewidth|w!
  \item Solid/dashed lines: \verb|dashtype| or \verb|dt|
    \begin{itemize}
      \item \verb|dt N|: predefined type
      \item \verb|dt "<pattern>"|: custom pattern where \verb|pattern| is a combination of dots, hyphens, underscores and spaces
      \item ATTENTION: set dash type before giving line type: \verb|plot x:sin(x) dt 1 w linespoints|
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{ImageJ} - \texttt{Fiji}}
\texttt{ImageJ} is a \texttt{Java}-based image processing program especially adapted to scientific researches. \texttt{Fiji} Is Just \texttt{ImageJ}, with many many plugins (you are advised to use this latter). Just a couple of tools that I have used (so that I don't forget them)
\begin{itemize}
  \item Rotate: \texttt{Image > Transform > Rotate}
  \item Set origin: usually the origin (the point (0,0)) is the upper left corner of the image. You can however change it: \texttt{Image > Transform > Properties > Origin} (do you need the \texttt{Global} case?)
  \item Since the origin point is by default at the top of the image, the y axis, that is the vertical one, has positive values towards the bottom. Sometimes is destabilizing. Change it with \texttt{Analyze > Set measurements > Invert y}
  \item Set a dimension scale from a part of the image whose dimension is known: draw a line than \texttt{Analyze > Set scale}
  \item Perspective: \texttt{Plugins > Transform > Interactive perspective}
  \item Make points from two different images correspond. Consider this. You have some photo of the same thing but you are a bad photographer and all the pictures have their own perspective and angle. Well, choose a reference photo than make all the other correspond to it with \texttt{Plugins > Transform > Landscape correspondences}
  \item Macros: in order to automate your process, you may write your own macros. See \texttt{Plugins > Macros > [...]}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%      SECTION      %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Miscellaneous}
\label{sec:misc}
\begin{itemize}
  \item \texttt{PETSc} \href{https://www.mcs.anl.gov/petsc/petsc-current/docs/manual.pdf}{manual}
    \begin{itemize}
      \item Use \verb|MatView(Mat a, PETSC_VIEWER_DRAW_WORLD)| or with any another \texttt{PetscViewer} to draw the nonzero structure of a matrix.
    \end{itemize}
  \item Create QR-codes: \href{https://www.qrcode-monkey.com/}{here} is a pretty simple, 100\% free and highly customizable QR-code generator.
\end{itemize}

\appendix
\begin{lstlisting}[language=bash,numbers=left,float,frame=single,caption={script.sh, an example for \texttt{getopts}},label={lst:getopt_ex},numberfirstline=true,stepnumber=5,firstnumber=1]
#!/bin/bash

usage () {
  echo "Usage: script.sh [ -p prefix ] [ -s suffix ]"
}

prfx=""
sffx=""

while getopts ":hp:s:" opt; do
  case "${opt}" in
    h )
      usage
      exit 0
      ;;
    p )
      prfx=${OPTARG}
      ;;
    s )
      sffx=${OPTARG}
      ;;
    : )
      echo "-${OPTARG}: An argument is required" 1>&2
      usage
      exit 1
      ;;
    \? )
      echo "-${OPTARG}: Unknown option" 1>&2
      usage
      exit 1
      ;;
  esac
done

echo "PFX = ${prfx}"
echo "SFX = ${sffx}"
\end{lstlisting}

\end{document}

